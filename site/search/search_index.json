{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Working with molecular structures in pandas DataFrames Links Documentation: http://rasbt.github.io/biopandas/ Source code repository: https://github.com/rasbt/biopandas PyPI: https://pypi.python.org/pypi/biopandas About If you are a computational biologist, chances are that you cursed one too many times about protein structure files. Yes, I am talking about ye Goode Olde Protein Data Bank format, aka \"PDB files.\" Nothing against PDB, it's a neatly structured format (if deployed correctly); yet, it is a bit cumbersome to work with PDB files in \"modern\" programming languages -- I am pretty sure we all agree on this. As machine learning and \"data science\" person, I fell in love with pandas DataFrames for handling just about everything that can be loaded into memory. So, why don't we take pandas to the structural biology world? Working with molecular structures of biological macromolecules (from PDB and MOL2 files) in pandas DataFrames is what BioPandas is all about! Examples # Initialize a new PandasPdb object # and fetch the PDB file from rcsb.org >>> from biopandas.pdb import PandasPdb >>> ppdb = PandasPdb().fetch_pdb('3eiy') >>> ppdb.df['ATOM'].head() # Load structures from your drive and compute the # Root Mean Square Deviation >>> from biopandas.pdb import PandasPdb >>> pl1 = PandasPdb().read_pdb('./docking_pose_1.pdb') >>> pl2 = PandasPdb().read_pdb('./docking_pose_2.pdb') >>> r = PandasPdb.rmsd(pl1.df['HETATM'], pl2.df['HETATM']) >>> print('RMSD: %.4f Angstrom' % r) RMSD: 2.6444 Angstrom # Producing quick summary plots >>> import matplotlib.pyplot as plt >>> ppdb.df['ATOM']['b_factor'].plot(kind='hist') >>> plt.title('Distribution of B-Factors') >>> plt.xlabel('B-factor') >>> plt.ylabel('count') >>> plt.show() >>> ppdb.df['ATOM']['b_factor'].plot(kind='line') >>> plt.title('B-Factors Along the Amino Acid Chain') >>> plt.xlabel('Residue Number') >>> plt.ylabel('B-factor in $A^2$') >>> plt.show() Cite as If you use BioPandas as part of your workflow in a scientific publication, please consider citing the BioPandas repository with the following DOI: Sebastian Raschka. Biopandas: Working with molecular structures in pandas dataframes. The Journal of Open Source Software , 2(14), jun 2017. doi: 10.21105/joss.00279. URL http://dx.doi.org/10.21105/joss.00279. @article{raschkas2017biopandas, doi = {10.21105/joss.00279}, url = {http://dx.doi.org/10.21105/joss.00279}, year = {2017}, month = {jun}, publisher = {The Open Journal}, volume = {2}, number = {14}, author = {Sebastian Raschka}, title = {BioPandas: Working with molecular structures in pandas DataFrames}, journal = {The Journal of Open Source Software} }","title":"Home"},{"location":"#links","text":"Documentation: http://rasbt.github.io/biopandas/ Source code repository: https://github.com/rasbt/biopandas PyPI: https://pypi.python.org/pypi/biopandas","title":"Links"},{"location":"#about","text":"If you are a computational biologist, chances are that you cursed one too many times about protein structure files. Yes, I am talking about ye Goode Olde Protein Data Bank format, aka \"PDB files.\" Nothing against PDB, it's a neatly structured format (if deployed correctly); yet, it is a bit cumbersome to work with PDB files in \"modern\" programming languages -- I am pretty sure we all agree on this. As machine learning and \"data science\" person, I fell in love with pandas DataFrames for handling just about everything that can be loaded into memory. So, why don't we take pandas to the structural biology world? Working with molecular structures of biological macromolecules (from PDB and MOL2 files) in pandas DataFrames is what BioPandas is all about!","title":"About"},{"location":"#examples","text":"# Initialize a new PandasPdb object # and fetch the PDB file from rcsb.org >>> from biopandas.pdb import PandasPdb >>> ppdb = PandasPdb().fetch_pdb('3eiy') >>> ppdb.df['ATOM'].head() # Load structures from your drive and compute the # Root Mean Square Deviation >>> from biopandas.pdb import PandasPdb >>> pl1 = PandasPdb().read_pdb('./docking_pose_1.pdb') >>> pl2 = PandasPdb().read_pdb('./docking_pose_2.pdb') >>> r = PandasPdb.rmsd(pl1.df['HETATM'], pl2.df['HETATM']) >>> print('RMSD: %.4f Angstrom' % r) RMSD: 2.6444 Angstrom # Producing quick summary plots >>> import matplotlib.pyplot as plt >>> ppdb.df['ATOM']['b_factor'].plot(kind='hist') >>> plt.title('Distribution of B-Factors') >>> plt.xlabel('B-factor') >>> plt.ylabel('count') >>> plt.show() >>> ppdb.df['ATOM']['b_factor'].plot(kind='line') >>> plt.title('B-Factors Along the Amino Acid Chain') >>> plt.xlabel('Residue Number') >>> plt.ylabel('B-factor in $A^2$') >>> plt.show()","title":"Examples"},{"location":"#cite-as","text":"If you use BioPandas as part of your workflow in a scientific publication, please consider citing the BioPandas repository with the following DOI: Sebastian Raschka. Biopandas: Working with molecular structures in pandas dataframes. The Journal of Open Source Software , 2(14), jun 2017. doi: 10.21105/joss.00279. URL http://dx.doi.org/10.21105/joss.00279. @article{raschkas2017biopandas, doi = {10.21105/joss.00279}, url = {http://dx.doi.org/10.21105/joss.00279}, year = {2017}, month = {jun}, publisher = {The Open Journal}, volume = {2}, number = {14}, author = {Sebastian Raschka}, title = {BioPandas: Working with molecular structures in pandas DataFrames}, journal = {The Journal of Open Source Software} }","title":"Cite as"},{"location":"CHANGELOG/","text":"Release Notes The CHANGELOG for the current development version is available at https://github.com/rasbt/biopandas/blob/master/docs/sources/CHANGELOG.md . 0.2.5 (07-09-2019) Downloads Source code (zip) Source code (tar.gz) New Features - Changes - Bug Fixes The PandasPdb.amino3to1 method now also considers insertion codes when converting the amino acid codes; before, inserted amino acides were skipped. 0.2.4 (02-05-2019) Downloads Source code (zip) Source code (tar.gz) New Features - Changes Minor adjustments to support to address deprecation warnings in pandas >= 23.0 Bug Fixes - 0.2.3 (03-29-2018) Downloads Source code (zip) Source code (tar.gz) New Features - Changes PandasMol2.distance_df was added as a static method that allows distance computations based for external data frames with its behavior otherwise similar to PandasMol2.distance . PandasPdb.distance_df was added as a static method that allows distance computations based for external data frames with its behavior otherwise similar to PandasPdb.distance . PandasPdb.distance now supports multiple record sections to be considered (e.g., records=('ATOM', 'HETATM') to include both protein and ligand in a query. Now also defaults to records=('ATOM', 'HETATM') for concistency with the impute method. PandasPdb.get(...) now supports external data frames and lets the user specify the record section to be considered (e.g., records=('ATOM', 'HETATM') to include both protein and ligand in a query. Now also defaults to records=('ATOM', 'HETATM') for concistency with the impute method. The section parameter of PandasPdb.impute_element(...) was renamed to records for API consistency. Bug Fixes - 0.2.2 (06-07-2017) Downloads Source code (zip) Source code (tar.gz) New Features - Changes Raises a meaningful error message if attempting to overwrite the df attributes of PandasMol2 and PandasPdb directly. Added PandasPdb.pdb_path and PandasMol2.mol2_path attributes that store the location of the data file last read. Bug Fixes The rmsd methods of PandasMol2 and PandasPdb don't return a NaN anymore if the array indices of to structures are different. 0.2.1 (2017-05-11) Downloads Source code (zip) Source code (tar.gz) New Features - Changes The amino3to1 method of biopandas.pdb.PandasPDB objects now returns a pandas DataFrame instead of a pandas Series object. The returned data frame has two columns, 'chain_id' and 'residue_name' , where the former contains the chain ID of the amino acid and the latter contains the 1-letter amino acid code, respectively. Significant speed improvements of the distance method of both PandasPdb and PandasMol2 (now about 300 percent faster than previously). Bug Fixes The amino3to1 method of biopandas.pdb.PandasPDB objects now handles multi-chain proteins correctly. The amino3to1 method of biopandas.pdb.PandasPDB objects now also works as expected if the 'ATOM' entry DataFrame contains disordered DataFrame indices or duplicate DataFrame index values. 0.2.0 (2017-04-02) Downloads Source code (zip) Source code (tar.gz) New Features Added an amino3to1 method to PandasPdb data frames to convert 3-amino acid letter codes to 1-letter codes. Added a distance method to PandasPdb data frames to compute the Euclidean distance between atoms and a reference point. Added the PandasMol2 class for working with Tripos MOL2 files in pandas DataFrames. Changes PandasPDB was renamed to PandasPdb . Raises a warning if PandasPdb is written to PDB and ATOM and HETAM section contains unexpected columns; these columns will now be skipped. Bug Fixes - 0.1.5 (2016-11-19) Downloads Source code (zip) Source code (tar.gz) New Features Added an impute_element method to PandasPDB objects to infer the Element Symbol from the Atom Name column. Added two new selection types for PandasPDB ATOM and HETATM coordinate sections: 'heavy' and 'carbon' . Changes Include test data in the PyPI package; add install_requires for pandas. The 'hydrogen' atom selection in PandasPDB methods is now based on the element type instead of the atom name. By default, the RMSD is now computed on all atoms unless a specific selection is defined. Bug Fixes - 0.1.4 (2015-11-24) Downloads Source code (zip) Source code (tar.gz) New Features - Changes Needed to bump the version number due to a bug in the PyPI setup.py script. Support for the old pandas sorting syntax ( DataFrame.sort vs DataFrame.sort_values ) incl. DeprecationWarning. Bug Fixes - 0.1.3 (2015-11-23) New Features - Changes - Bug Fixes Exception handling in tests if PDB goes down (which just happened). Added a separate ANISOU engine to handle those records correctly. 0.1.2 (2015-11-23) First Release.","title":"Changelog"},{"location":"CHANGELOG/#release-notes","text":"The CHANGELOG for the current development version is available at https://github.com/rasbt/biopandas/blob/master/docs/sources/CHANGELOG.md .","title":"Release Notes"},{"location":"CHANGELOG/#025-07-09-2019","text":"","title":"0.2.5 (07-09-2019)"},{"location":"CHANGELOG/#downloads","text":"Source code (zip) Source code (tar.gz)","title":"Downloads"},{"location":"CHANGELOG/#new-features","text":"-","title":"New Features"},{"location":"CHANGELOG/#changes","text":"-","title":"Changes"},{"location":"CHANGELOG/#bug-fixes","text":"The PandasPdb.amino3to1 method now also considers insertion codes when converting the amino acid codes; before, inserted amino acides were skipped.","title":"Bug Fixes"},{"location":"CHANGELOG/#024-02-05-2019","text":"","title":"0.2.4 (02-05-2019)"},{"location":"CHANGELOG/#downloads_1","text":"Source code (zip) Source code (tar.gz)","title":"Downloads"},{"location":"CHANGELOG/#new-features_1","text":"-","title":"New Features"},{"location":"CHANGELOG/#changes_1","text":"Minor adjustments to support to address deprecation warnings in pandas >= 23.0","title":"Changes"},{"location":"CHANGELOG/#bug-fixes_1","text":"-","title":"Bug Fixes"},{"location":"CHANGELOG/#023-03-29-2018","text":"","title":"0.2.3 (03-29-2018)"},{"location":"CHANGELOG/#downloads_2","text":"Source code (zip) Source code (tar.gz)","title":"Downloads"},{"location":"CHANGELOG/#new-features_2","text":"-","title":"New Features"},{"location":"CHANGELOG/#changes_2","text":"PandasMol2.distance_df was added as a static method that allows distance computations based for external data frames with its behavior otherwise similar to PandasMol2.distance . PandasPdb.distance_df was added as a static method that allows distance computations based for external data frames with its behavior otherwise similar to PandasPdb.distance . PandasPdb.distance now supports multiple record sections to be considered (e.g., records=('ATOM', 'HETATM') to include both protein and ligand in a query. Now also defaults to records=('ATOM', 'HETATM') for concistency with the impute method. PandasPdb.get(...) now supports external data frames and lets the user specify the record section to be considered (e.g., records=('ATOM', 'HETATM') to include both protein and ligand in a query. Now also defaults to records=('ATOM', 'HETATM') for concistency with the impute method. The section parameter of PandasPdb.impute_element(...) was renamed to records for API consistency.","title":"Changes"},{"location":"CHANGELOG/#bug-fixes_2","text":"-","title":"Bug Fixes"},{"location":"CHANGELOG/#022-06-07-2017","text":"","title":"0.2.2 (06-07-2017)"},{"location":"CHANGELOG/#downloads_3","text":"Source code (zip) Source code (tar.gz)","title":"Downloads"},{"location":"CHANGELOG/#new-features_3","text":"-","title":"New Features"},{"location":"CHANGELOG/#changes_3","text":"Raises a meaningful error message if attempting to overwrite the df attributes of PandasMol2 and PandasPdb directly. Added PandasPdb.pdb_path and PandasMol2.mol2_path attributes that store the location of the data file last read.","title":"Changes"},{"location":"CHANGELOG/#bug-fixes_3","text":"The rmsd methods of PandasMol2 and PandasPdb don't return a NaN anymore if the array indices of to structures are different.","title":"Bug Fixes"},{"location":"CHANGELOG/#021-2017-05-11","text":"","title":"0.2.1  (2017-05-11)"},{"location":"CHANGELOG/#downloads_4","text":"Source code (zip) Source code (tar.gz)","title":"Downloads"},{"location":"CHANGELOG/#new-features_4","text":"-","title":"New Features"},{"location":"CHANGELOG/#changes_4","text":"The amino3to1 method of biopandas.pdb.PandasPDB objects now returns a pandas DataFrame instead of a pandas Series object. The returned data frame has two columns, 'chain_id' and 'residue_name' , where the former contains the chain ID of the amino acid and the latter contains the 1-letter amino acid code, respectively. Significant speed improvements of the distance method of both PandasPdb and PandasMol2 (now about 300 percent faster than previously).","title":"Changes"},{"location":"CHANGELOG/#bug-fixes_4","text":"The amino3to1 method of biopandas.pdb.PandasPDB objects now handles multi-chain proteins correctly. The amino3to1 method of biopandas.pdb.PandasPDB objects now also works as expected if the 'ATOM' entry DataFrame contains disordered DataFrame indices or duplicate DataFrame index values.","title":"Bug Fixes"},{"location":"CHANGELOG/#020-2017-04-02","text":"","title":"0.2.0 (2017-04-02)"},{"location":"CHANGELOG/#downloads_5","text":"Source code (zip) Source code (tar.gz)","title":"Downloads"},{"location":"CHANGELOG/#new-features_5","text":"Added an amino3to1 method to PandasPdb data frames to convert 3-amino acid letter codes to 1-letter codes. Added a distance method to PandasPdb data frames to compute the Euclidean distance between atoms and a reference point. Added the PandasMol2 class for working with Tripos MOL2 files in pandas DataFrames.","title":"New Features"},{"location":"CHANGELOG/#changes_5","text":"PandasPDB was renamed to PandasPdb . Raises a warning if PandasPdb is written to PDB and ATOM and HETAM section contains unexpected columns; these columns will now be skipped.","title":"Changes"},{"location":"CHANGELOG/#bug-fixes_5","text":"-","title":"Bug Fixes"},{"location":"CHANGELOG/#015-2016-11-19","text":"","title":"0.1.5 (2016-11-19)"},{"location":"CHANGELOG/#downloads_6","text":"Source code (zip) Source code (tar.gz)","title":"Downloads"},{"location":"CHANGELOG/#new-features_6","text":"Added an impute_element method to PandasPDB objects to infer the Element Symbol from the Atom Name column. Added two new selection types for PandasPDB ATOM and HETATM coordinate sections: 'heavy' and 'carbon' .","title":"New Features"},{"location":"CHANGELOG/#changes_6","text":"Include test data in the PyPI package; add install_requires for pandas. The 'hydrogen' atom selection in PandasPDB methods is now based on the element type instead of the atom name. By default, the RMSD is now computed on all atoms unless a specific selection is defined.","title":"Changes"},{"location":"CHANGELOG/#bug-fixes_6","text":"-","title":"Bug Fixes"},{"location":"CHANGELOG/#014-2015-11-24","text":"","title":"0.1.4 (2015-11-24)"},{"location":"CHANGELOG/#downloads_7","text":"Source code (zip) Source code (tar.gz)","title":"Downloads"},{"location":"CHANGELOG/#new-features_7","text":"-","title":"New Features"},{"location":"CHANGELOG/#changes_7","text":"Needed to bump the version number due to a bug in the PyPI setup.py script. Support for the old pandas sorting syntax ( DataFrame.sort vs DataFrame.sort_values ) incl. DeprecationWarning.","title":"Changes"},{"location":"CHANGELOG/#bug-fixes_7","text":"-","title":"Bug Fixes"},{"location":"CHANGELOG/#013-2015-11-23","text":"","title":"0.1.3 (2015-11-23)"},{"location":"CHANGELOG/#new-features_8","text":"-","title":"New Features"},{"location":"CHANGELOG/#changes_8","text":"-","title":"Changes"},{"location":"CHANGELOG/#bug-fixes_8","text":"Exception handling in tests if PDB goes down (which just happened). Added a separate ANISOU engine to handle those records correctly.","title":"Bug Fixes"},{"location":"CHANGELOG/#012-2015-11-23","text":"First Release.","title":"0.1.2 (2015-11-23)"},{"location":"CONTRIBUTING/","text":"How to Contribute I would be very happy about any kind of contributions that help to improve and extend the functionality of biopandas. Quick Contributor Checklist This is a quick checklist about the different steps of a typical contribution to biopandas and other open source projects. Consider copying this list to a local text file (or the issue tracker) and checking off items as you go. [ ] Open a new \"issue\" on GitHub to discuss the new feature / bug fix [ ] Fork the biopandas repository from GitHub (if not already done earlier) [ ] Create and checkout a new topic branch [ ] Implement new feature or apply the bug-fix [ ] Add appropriate unit test functions [ ] Run nosetests -sv and make sure that all unit tests pass [ ] Check/improve the test coverage by running nosetests --with-coverage [ ] Add a note about the change to the ./docs/sources/CHANGELOG.md file [ ] Modify documentation in the appropriate location under biopandas/docs/sources/ [ ] Push the topic branch to the server and create a pull request [ ] Check the Travis-CI build passed at https://travis-ci.org/rasbt/biopandas [ ] Check/improve the unit test coverage at https://coveralls.io/github/rasbt/biopandas [ ] Check/improve the code health at https://landscape.io/github/rasbt/biopandas [ ] Squash many small commits to a larger commit Getting Started - Creating a New Issue and Forking the Repository If you don't have a GitHub account yet, please create one to contribute to this project. Please submit a ticket for your issue to discuss the fix or new feature before too much time and effort is spent for the implementation. Fork the biopandas repository from the GitHub web interface. Clone the biopandas repository to your local machine git clone https://github.com/<your_username>/biopandas.git Syncing an Existing Fork If you already forked biopandas earlier, you can bring you \"Fork\" up to date with the master branch as follows: 1. Configuring a remote that points to the upstream repository on GitHub List the current configured remote repository for your fork by executing $ git remote -v If you see something like origin https://github.com/<your username>/biopandas.git (fetch) origin https://github.com/<your username>/biopandas.git (push) you need to specify a new remote upstream repository via $ git remote add upstream https://github.com/rasbt/biopandas.git Now, verify the new upstream repository you've specified for your fork by executing $ git remote -v You should see following output if everything is configured correctly: origin https://github.com/<your username>/biopandas.git (fetch) origin https://github.com/<your username>/biopandas.git (push) upstream https://github.com/rasbt/biopandas.git (fetch) upstream https://github.com/rasbt/biopandas.git (push) 2. Syncing your Fork First, fetch the updates of the original project's master branch by executing: $ git fetch upstream You should see the following output remote: Counting objects: xx, done. remote: Compressing objects: 100% (xx/xx), done. remote: Total xx (delta xx), reused xx (delta x) Unpacking objects: 100% (xx/xx), done. From https://github.com/rasbt/biopandas * [new branch] master -> upstream/master This means that the commits to the rasbt/biopandas master branch are now stored in the local branch upstream/master . If you are not already on your local project's master branch, execute $ git checkout master Finally, merge the changes in upstream/master to your local master branch by executing $ git merge upstream/master which will give you an output that looks similar to Updating xxx...xxx Fast-forward SOME FILE1 | 12 +++++++ SOME FILE2 | 10 +++++++ 2 files changed, 22 insertions(+), Making Changes in a New Topic Branch 1. Creating a new feature branch Please avoid working directly on the master branch but create a new feature branch: $ git branch <new_feature> Switch to the new feature branch by executing $ git checkout <new_feature> 2. Developing the new feature / bug fix 3. Testing your code Adding/modifying the unit tests and check if they pass: $ nosetests -sv $ nosetests --with-coverage 4. Documenting the changes Please add an entry to the biopandas/docs/sources/CHANGELOG.md file. If it is a new feature, it would also be nice if you could update the documentation in appropriate location in biopandas/sources . 5. Committing the changes When you are ready to commit the changes, please provide a meaningful commit message: $ git add <modifies_files> # or `git add .` $ git commit -m '<meaningful commit message>' 6. Optional: squashing commits If you made multiple smaller commits, it would be nice if you could group them into a larger, summarizing commit. First, list your recent commit via $ git log which will list the commits from newest to oldest in the following format by default: commit 046e3af8a9127df8eac879454f029937c8a31c41 Author: rasbt <mail@sebastianraschka.com> Date: Tue Nov 24 03:46:37 2015 -0500 fixed setup.py commit c3c00f6ba0e8f48bbe1c9081b8ae3817e57ecc5c Author: rasbt <mail@sebastianraschka.com> Date: Tue Nov 24 03:04:39 2015 -0500 documented feature x commit d87934fe8726c46f0b166d6290a3bf38915d6e75 Author: rasbt <mail@sebastianraschka.com> Date: Tue Nov 24 02:44:45 2015 -0500 added support for feature x Assuming that it would make sense to group these 3 commits into one, we can execute $ git rebase -i HEAD~3 which will bring our default git editor with the following contents: pick d87934f added support for feature x pick c3c00f6 documented feature x pick 046e3af fixed setup.py Since c3c00f6 and 046e3af are related to the original commit of feature x , let's keep the d87934f and squash the 2 following commits into this initial one by changes the lines to pick d87934f added support for feature x squash c3c00f6 documented feature x squash 046e3af fixed setup.py Now, save the changes in your editor. Now, quitting the editor will apply the rebase changes, and the editor will open a second time, prompting you to enter a new commit message. In this case, we could enter support for feature x to summarize the contributions. 7. Uploading the changes Push your changes to a topic branch to the git server by executing: $ git push origin <feature_branch> 8. Submitting a pull request Go to your GitHub repository online, select the new feature branch, and submit a new pull request: Notes for the Developers Building the documentation The documentation is built via MkDocs ; to ensure that the documentation is rendered correctly, you can view the documentation locally by executing mkdocs serve from the biopandas/docs directory. For example, ~/github/biopandas/docs$ mkdocs serve 1. Editing the Tutorials Please note that documents containing code examples are generated from IPython Notebook files and converted to markdown via ~/github/biopandas/docs/sources/tutorials$ nbconvert --to markdown <file.ipynb> The markdown file should be placed into the documentation directory at biopandas/docs/sources to build the documentation via MkDocs. If you are adding a new document, please also include it in the pages section in the biopandas/docs/mkdocs.yml file. 2. Building the API documentation To build the API documentation, navigate to biopandas/docs and execute the make_api.py file from this directory via ~/github/biopandas/docs$ python make_api.py This should place the API documentation into the correct directories in biopandas/docs/sources/api . 3. Building static HTML files of the documentation Build the static HTML files of the biopandas documentation via ~/github/biopandas/docs$ mkdocs build --clean To deploy the documentation, execute ~/github/biopandas/docs$ mkdocs gh-deploy --clean Uploading a new version to PyPI 1. Creating a new testing environment Assuming we are using conda , create a new python environment via $ conda create -n 'biopandas-testing' python=3 pandas Next, activate the environment by executing $ source activate biopandas-testing 2. Installing the package from local files Test the installation by executing $ python setup.py install --record files.txt the --record files.txt flag will create a files.txt file listing the locations where these files will be installed. Try to import the package to see if it works, for example, by executing $ python -c 'import biopandas; print(biopandas.__file__)' If everything seems to be fine, remove the installation via $ cat files.txt | xargs rm -rf ; rm files.txt Next, test if pip is able to install the packages. First, navigate to a different directory, and from there, install the package: $ pip install code/biopandas/ and uninstall it again $ pip uninstall biopandas 3. Deploying the package Consider deploying the package to the PyPI test server first. The setup instructions can be found here . $ python setup.py sdist bdist_wheel upload -r https://testpypi.python.org/pypi Test if it can be installed from there by executing $ pip install -i https://testpypi.python.org/pypi biopandas and uninstall it $ pip uninstall biopandas After this dry-run succeeded, repeat this process using the \"real\" PyPI: $ python setup.py sdist bdist_wheel upload 4. Removing the virtual environment Finally, to cleanup our local drive, remove the virtual testing environment via $ conda remove --name 'biopandas-testing' --all","title":"Contributing"},{"location":"CONTRIBUTING/#how-to-contribute","text":"I would be very happy about any kind of contributions that help to improve and extend the functionality of biopandas.","title":"How to Contribute"},{"location":"CONTRIBUTING/#quick-contributor-checklist","text":"This is a quick checklist about the different steps of a typical contribution to biopandas and other open source projects. Consider copying this list to a local text file (or the issue tracker) and checking off items as you go. [ ] Open a new \"issue\" on GitHub to discuss the new feature / bug fix [ ] Fork the biopandas repository from GitHub (if not already done earlier) [ ] Create and checkout a new topic branch [ ] Implement new feature or apply the bug-fix [ ] Add appropriate unit test functions [ ] Run nosetests -sv and make sure that all unit tests pass [ ] Check/improve the test coverage by running nosetests --with-coverage [ ] Add a note about the change to the ./docs/sources/CHANGELOG.md file [ ] Modify documentation in the appropriate location under biopandas/docs/sources/ [ ] Push the topic branch to the server and create a pull request [ ] Check the Travis-CI build passed at https://travis-ci.org/rasbt/biopandas [ ] Check/improve the unit test coverage at https://coveralls.io/github/rasbt/biopandas [ ] Check/improve the code health at https://landscape.io/github/rasbt/biopandas [ ] Squash many small commits to a larger commit","title":"Quick Contributor Checklist"},{"location":"CONTRIBUTING/#getting-started-creating-a-new-issue-and-forking-the-repository","text":"If you don't have a GitHub account yet, please create one to contribute to this project. Please submit a ticket for your issue to discuss the fix or new feature before too much time and effort is spent for the implementation. Fork the biopandas repository from the GitHub web interface. Clone the biopandas repository to your local machine git clone https://github.com/<your_username>/biopandas.git","title":"Getting Started - Creating a New Issue and Forking the Repository"},{"location":"CONTRIBUTING/#syncing-an-existing-fork","text":"If you already forked biopandas earlier, you can bring you \"Fork\" up to date with the master branch as follows:","title":"Syncing an Existing Fork"},{"location":"CONTRIBUTING/#1-configuring-a-remote-that-points-to-the-upstream-repository-on-github","text":"List the current configured remote repository for your fork by executing $ git remote -v If you see something like origin https://github.com/<your username>/biopandas.git (fetch) origin https://github.com/<your username>/biopandas.git (push) you need to specify a new remote upstream repository via $ git remote add upstream https://github.com/rasbt/biopandas.git Now, verify the new upstream repository you've specified for your fork by executing $ git remote -v You should see following output if everything is configured correctly: origin https://github.com/<your username>/biopandas.git (fetch) origin https://github.com/<your username>/biopandas.git (push) upstream https://github.com/rasbt/biopandas.git (fetch) upstream https://github.com/rasbt/biopandas.git (push)","title":"1. Configuring a remote that points to the upstream repository on GitHub"},{"location":"CONTRIBUTING/#2-syncing-your-fork","text":"First, fetch the updates of the original project's master branch by executing: $ git fetch upstream You should see the following output remote: Counting objects: xx, done. remote: Compressing objects: 100% (xx/xx), done. remote: Total xx (delta xx), reused xx (delta x) Unpacking objects: 100% (xx/xx), done. From https://github.com/rasbt/biopandas * [new branch] master -> upstream/master This means that the commits to the rasbt/biopandas master branch are now stored in the local branch upstream/master . If you are not already on your local project's master branch, execute $ git checkout master Finally, merge the changes in upstream/master to your local master branch by executing $ git merge upstream/master which will give you an output that looks similar to Updating xxx...xxx Fast-forward SOME FILE1 | 12 +++++++ SOME FILE2 | 10 +++++++ 2 files changed, 22 insertions(+),","title":"2. Syncing your Fork"},{"location":"CONTRIBUTING/#making-changes-in-a-new-topic-branch","text":"","title":"Making Changes in a New Topic Branch"},{"location":"CONTRIBUTING/#1-creating-a-new-feature-branch","text":"Please avoid working directly on the master branch but create a new feature branch: $ git branch <new_feature> Switch to the new feature branch by executing $ git checkout <new_feature>","title":"1. Creating a new feature branch"},{"location":"CONTRIBUTING/#2-developing-the-new-feature-bug-fix","text":"","title":"2. Developing the new feature / bug fix"},{"location":"CONTRIBUTING/#3-testing-your-code","text":"Adding/modifying the unit tests and check if they pass: $ nosetests -sv $ nosetests --with-coverage","title":"3. Testing your code"},{"location":"CONTRIBUTING/#4-documenting-the-changes","text":"Please add an entry to the biopandas/docs/sources/CHANGELOG.md file. If it is a new feature, it would also be nice if you could update the documentation in appropriate location in biopandas/sources .","title":"4. Documenting the changes"},{"location":"CONTRIBUTING/#5-committing-the-changes","text":"When you are ready to commit the changes, please provide a meaningful commit message: $ git add <modifies_files> # or `git add .` $ git commit -m '<meaningful commit message>'","title":"5. Committing the changes"},{"location":"CONTRIBUTING/#6-optional-squashing-commits","text":"If you made multiple smaller commits, it would be nice if you could group them into a larger, summarizing commit. First, list your recent commit via $ git log which will list the commits from newest to oldest in the following format by default: commit 046e3af8a9127df8eac879454f029937c8a31c41 Author: rasbt <mail@sebastianraschka.com> Date: Tue Nov 24 03:46:37 2015 -0500 fixed setup.py commit c3c00f6ba0e8f48bbe1c9081b8ae3817e57ecc5c Author: rasbt <mail@sebastianraschka.com> Date: Tue Nov 24 03:04:39 2015 -0500 documented feature x commit d87934fe8726c46f0b166d6290a3bf38915d6e75 Author: rasbt <mail@sebastianraschka.com> Date: Tue Nov 24 02:44:45 2015 -0500 added support for feature x Assuming that it would make sense to group these 3 commits into one, we can execute $ git rebase -i HEAD~3 which will bring our default git editor with the following contents: pick d87934f added support for feature x pick c3c00f6 documented feature x pick 046e3af fixed setup.py Since c3c00f6 and 046e3af are related to the original commit of feature x , let's keep the d87934f and squash the 2 following commits into this initial one by changes the lines to pick d87934f added support for feature x squash c3c00f6 documented feature x squash 046e3af fixed setup.py Now, save the changes in your editor. Now, quitting the editor will apply the rebase changes, and the editor will open a second time, prompting you to enter a new commit message. In this case, we could enter support for feature x to summarize the contributions.","title":"6. Optional: squashing commits"},{"location":"CONTRIBUTING/#7-uploading-the-changes","text":"Push your changes to a topic branch to the git server by executing: $ git push origin <feature_branch>","title":"7. Uploading the changes"},{"location":"CONTRIBUTING/#8-submitting-a-pull-request","text":"Go to your GitHub repository online, select the new feature branch, and submit a new pull request:","title":"8. Submitting a pull request"},{"location":"CONTRIBUTING/#notes-for-the-developers","text":"","title":"Notes for the Developers"},{"location":"CONTRIBUTING/#building-the-documentation","text":"The documentation is built via MkDocs ; to ensure that the documentation is rendered correctly, you can view the documentation locally by executing mkdocs serve from the biopandas/docs directory. For example, ~/github/biopandas/docs$ mkdocs serve","title":"Building the documentation"},{"location":"CONTRIBUTING/#1-editing-the-tutorials","text":"Please note that documents containing code examples are generated from IPython Notebook files and converted to markdown via ~/github/biopandas/docs/sources/tutorials$ nbconvert --to markdown <file.ipynb> The markdown file should be placed into the documentation directory at biopandas/docs/sources to build the documentation via MkDocs. If you are adding a new document, please also include it in the pages section in the biopandas/docs/mkdocs.yml file.","title":"1.  Editing the Tutorials"},{"location":"CONTRIBUTING/#2-building-the-api-documentation","text":"To build the API documentation, navigate to biopandas/docs and execute the make_api.py file from this directory via ~/github/biopandas/docs$ python make_api.py This should place the API documentation into the correct directories in biopandas/docs/sources/api .","title":"2. Building the API documentation"},{"location":"CONTRIBUTING/#3-building-static-html-files-of-the-documentation","text":"Build the static HTML files of the biopandas documentation via ~/github/biopandas/docs$ mkdocs build --clean To deploy the documentation, execute ~/github/biopandas/docs$ mkdocs gh-deploy --clean","title":"3. Building static HTML files of the documentation"},{"location":"CONTRIBUTING/#uploading-a-new-version-to-pypi","text":"","title":"Uploading a new version to PyPI"},{"location":"CONTRIBUTING/#1-creating-a-new-testing-environment","text":"Assuming we are using conda , create a new python environment via $ conda create -n 'biopandas-testing' python=3 pandas Next, activate the environment by executing $ source activate biopandas-testing","title":"1. Creating a new testing environment"},{"location":"CONTRIBUTING/#2-installing-the-package-from-local-files","text":"Test the installation by executing $ python setup.py install --record files.txt the --record files.txt flag will create a files.txt file listing the locations where these files will be installed. Try to import the package to see if it works, for example, by executing $ python -c 'import biopandas; print(biopandas.__file__)' If everything seems to be fine, remove the installation via $ cat files.txt | xargs rm -rf ; rm files.txt Next, test if pip is able to install the packages. First, navigate to a different directory, and from there, install the package: $ pip install code/biopandas/ and uninstall it again $ pip uninstall biopandas","title":"2. Installing the package from local files"},{"location":"CONTRIBUTING/#3-deploying-the-package","text":"Consider deploying the package to the PyPI test server first. The setup instructions can be found here . $ python setup.py sdist bdist_wheel upload -r https://testpypi.python.org/pypi Test if it can be installed from there by executing $ pip install -i https://testpypi.python.org/pypi biopandas and uninstall it $ pip uninstall biopandas After this dry-run succeeded, repeat this process using the \"real\" PyPI: $ python setup.py sdist bdist_wheel upload","title":"3. Deploying the package"},{"location":"CONTRIBUTING/#4-removing-the-virtual-environment","text":"Finally, to cleanup our local drive, remove the virtual testing environment via $ conda remove --name 'biopandas-testing' --all","title":"4. Removing the virtual environment"},{"location":"citing/","text":"Citing If you use BioPandas as part of your workflow in a scientific publication, please consider citing the BioPandas repository with the following DOI: Sebastian Raschka. Biopandas: Working with molecular structures in pandas dataframes. The Journal of Open Source Software , 2(14), jun 2017. doi: 10.21105/joss.00279. URL http://dx.doi.org/10.21105/joss.00279. @article{raschkas2017biopandas, doi = {10.21105/joss.00279}, url = {http://dx.doi.org/10.21105/joss.00279}, year = {2017}, month = {jun}, publisher = {The Open Journal}, volume = {2}, number = {14}, author = {Sebastian Raschka}, title = {BioPandas: Working with molecular structures in pandas DataFrames}, journal = {The Journal of Open Source Software} }","title":"Citing"},{"location":"citing/#citing","text":"If you use BioPandas as part of your workflow in a scientific publication, please consider citing the BioPandas repository with the following DOI: Sebastian Raschka. Biopandas: Working with molecular structures in pandas dataframes. The Journal of Open Source Software , 2(14), jun 2017. doi: 10.21105/joss.00279. URL http://dx.doi.org/10.21105/joss.00279. @article{raschkas2017biopandas, doi = {10.21105/joss.00279}, url = {http://dx.doi.org/10.21105/joss.00279}, year = {2017}, month = {jun}, publisher = {The Open Journal}, volume = {2}, number = {14}, author = {Sebastian Raschka}, title = {BioPandas: Working with molecular structures in pandas DataFrames}, journal = {The Journal of Open Source Software} }","title":"Citing"},{"location":"installation/","text":"Installing BioPandas Requirements BioPandas requires the following software and packages: Python 2.7, 3.5, or 3.6 NumPy >= 1.11.2 SciPy >= 0.18.1 Pandas >= 0.19.1 PyPI You can install the latest stable release of biopandas directly from Python's package index via pip by executing the following code from your command line: pip install biopandas Conda-forge Versions of biopandas are now also available via conda-forge ; you can install it via conda install biopandas -c conda-forge or simply conda install biopandas if you have conda-forge already added to your channels . Latest GitHub Source Code You want to try out the latest features before they go live on PyPI? Install the biopandas dev-version latest development version from the GitHub repository by executing pip install git+git://github.com/rasbt/biopandas.git Alternatively, you download the package manually from PYPI or GitHub , unzip it, navigate into the package, and execute the command: python setup.py install","title":"Installation"},{"location":"installation/#installing-biopandas","text":"","title":"Installing BioPandas"},{"location":"installation/#requirements","text":"BioPandas requires the following software and packages: Python 2.7, 3.5, or 3.6 NumPy >= 1.11.2 SciPy >= 0.18.1 Pandas >= 0.19.1","title":"Requirements"},{"location":"installation/#pypi","text":"You can install the latest stable release of biopandas directly from Python's package index via pip by executing the following code from your command line: pip install biopandas","title":"PyPI"},{"location":"installation/#conda-forge","text":"Versions of biopandas are now also available via conda-forge ; you can install it via conda install biopandas -c conda-forge or simply conda install biopandas if you have conda-forge already added to your channels .","title":"Conda-forge"},{"location":"installation/#latest-github-source-code","text":"You want to try out the latest features before they go live on PyPI? Install the biopandas dev-version latest development version from the GitHub repository by executing pip install git+git://github.com/rasbt/biopandas.git Alternatively, you download the package manually from PYPI or GitHub , unzip it, navigate into the package, and execute the command: python setup.py install","title":"Latest GitHub Source Code"},{"location":"api_modules/biopandas.mol2/PandasMol2/","text":"PandasMol2 PandasMol2() Object for working with Tripos Mol2 structure files. Attributes df : pandas.DataFrame DataFrame of a Mol2's ATOM section mol2_text : str Mol2 file contents in string format code : str ID, code, or name of the molecule stored pdb_path : str Location of the MOL2 file that was read in via read_mol2 Methods distance(xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms in self.df and a 3D point. Parameters xyz : tuple (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the atom section and xyz . distance_df(df, xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms and a 3D point. Parameters df : DataFrame DataFrame containing entries similar to the PandasMol2.df format for the the distance computation to the xyz reference coordinates. xyz : tuple (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the atom section and xyz . read_mol2(path, columns=None) Reads Mol2 files (unzipped or gzipped) from local drive Note that if your mol2 file contains more than one molecule, only the first molecule is loaded into the DataFrame Attributes path : str Path to the Mol2 file in .mol2 format or gzipped format (.mol2.gz) columns : dict or None (default: None) If None, this methods expects a 9-column ATOM section that contains the following columns: {0:('atom_id', int), 1:('atom_name', str), 2:('x', float), 3:('y', float), 4:('z', float), 5:('atom_type', str), 6:('subst_id', int), 7:('subst_name', str), 8:('charge', float)} If your Mol2 files are formatted differently, you can provide your own column_mapping dictionary in a format similar to the one above. However, note that not all assert_raise_message methods may be supported then. Returns self read_mol2_from_list(mol2_lines, mol2_code, columns=None) Reads Mol2 file from a list into DataFrames Attributes mol2_lines : list A list of lines containing the mol2 file contents. For example, ['@ MOLECULE\\n', 'ZINC38611810\\n', ' 65 68 0 0 0\\n', 'SMALL\\n', 'NO_CHARGES\\n', '\\n', '@ ATOM\\n', ' 1 C1 -1.1786 2.7011 -4.0323 C.3 1 <0> -0.1537\\n', ' 2 C2 -1.2950 1.2442 -3.5798 C.3 1 <0> -0.1156\\n', ...] mol2_code : str or None Name or ID of the molecule. columns : dict or None (default: None) If None, this methods expects a 9-column ATOM section that contains the following columns: {0:('atom_id', int), 1:('atom_name', str), 2:('x', float), 3:('y', float), 4:('z', float), 5:('atom_type', str), 6:('subst_id', int), 7:('subst_name', str), 8:('charge', float)} If your Mol2 files are formatted differently, you can provide your own column_mapping dictionary in a format similar to the one above. However, note that not all assert_raise_message methods may be supported then. Returns self rmsd(df1, df2, heavy_only=True) Compute the Root Mean Square Deviation between molecules Parameters df1 : pandas.DataFrame DataFrame with HETATM, ATOM, and/or ANISOU entries df2 : pandas.DataFrame Second DataFrame for RMSD computation against df1. Must have the same number of entries as df1 heavy_only : bool (default: True) Which atoms to compare to compute the RMSD. If True (default), computes the RMSD between non-hydrogen atoms only. Returns rmsd : float Root Mean Square Deviation between df1 and df2 Properties df Acccesses the pandas DataFrame","title":"PandasMol2"},{"location":"api_modules/biopandas.mol2/PandasMol2/#pandasmol2","text":"PandasMol2() Object for working with Tripos Mol2 structure files. Attributes df : pandas.DataFrame DataFrame of a Mol2's ATOM section mol2_text : str Mol2 file contents in string format code : str ID, code, or name of the molecule stored pdb_path : str Location of the MOL2 file that was read in via read_mol2","title":"PandasMol2"},{"location":"api_modules/biopandas.mol2/PandasMol2/#methods","text":"distance(xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms in self.df and a 3D point. Parameters xyz : tuple (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the atom section and xyz . distance_df(df, xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms and a 3D point. Parameters df : DataFrame DataFrame containing entries similar to the PandasMol2.df format for the the distance computation to the xyz reference coordinates. xyz : tuple (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the atom section and xyz . read_mol2(path, columns=None) Reads Mol2 files (unzipped or gzipped) from local drive Note that if your mol2 file contains more than one molecule, only the first molecule is loaded into the DataFrame Attributes path : str Path to the Mol2 file in .mol2 format or gzipped format (.mol2.gz) columns : dict or None (default: None) If None, this methods expects a 9-column ATOM section that contains the following columns: {0:('atom_id', int), 1:('atom_name', str), 2:('x', float), 3:('y', float), 4:('z', float), 5:('atom_type', str), 6:('subst_id', int), 7:('subst_name', str), 8:('charge', float)} If your Mol2 files are formatted differently, you can provide your own column_mapping dictionary in a format similar to the one above. However, note that not all assert_raise_message methods may be supported then. Returns self read_mol2_from_list(mol2_lines, mol2_code, columns=None) Reads Mol2 file from a list into DataFrames Attributes mol2_lines : list A list of lines containing the mol2 file contents. For example, ['@ MOLECULE\\n', 'ZINC38611810\\n', ' 65 68 0 0 0\\n', 'SMALL\\n', 'NO_CHARGES\\n', '\\n', '@ ATOM\\n', ' 1 C1 -1.1786 2.7011 -4.0323 C.3 1 <0> -0.1537\\n', ' 2 C2 -1.2950 1.2442 -3.5798 C.3 1 <0> -0.1156\\n', ...] mol2_code : str or None Name or ID of the molecule. columns : dict or None (default: None) If None, this methods expects a 9-column ATOM section that contains the following columns: {0:('atom_id', int), 1:('atom_name', str), 2:('x', float), 3:('y', float), 4:('z', float), 5:('atom_type', str), 6:('subst_id', int), 7:('subst_name', str), 8:('charge', float)} If your Mol2 files are formatted differently, you can provide your own column_mapping dictionary in a format similar to the one above. However, note that not all assert_raise_message methods may be supported then. Returns self rmsd(df1, df2, heavy_only=True) Compute the Root Mean Square Deviation between molecules Parameters df1 : pandas.DataFrame DataFrame with HETATM, ATOM, and/or ANISOU entries df2 : pandas.DataFrame Second DataFrame for RMSD computation against df1. Must have the same number of entries as df1 heavy_only : bool (default: True) Which atoms to compare to compute the RMSD. If True (default), computes the RMSD between non-hydrogen atoms only. Returns rmsd : float Root Mean Square Deviation between df1 and df2","title":"Methods"},{"location":"api_modules/biopandas.mol2/PandasMol2/#properties","text":"df Acccesses the pandas DataFrame","title":"Properties"},{"location":"api_modules/biopandas.mol2/split_multimol2/","text":"split_multimol2 split_multimol2(mol2_path) Splits a multi-mol2 file into individual Mol2 file contents. Parameters mol2_path : str Path to the multi-mol2 file. Parses gzip files if the filepath ends on .gz. Returns A generator object for lists for every extracted mol2-file. Lists contain the molecule ID and the mol2 file contents. e.g., ['ID1234', ['@ MOLECULE\\n', '...']]. Note that bytestrings are returned (for reasons of efficieny) if the Mol2 content is read from a gzip (.gz) file.","title":"Split multimol2"},{"location":"api_modules/biopandas.mol2/split_multimol2/#split_multimol2","text":"split_multimol2(mol2_path) Splits a multi-mol2 file into individual Mol2 file contents. Parameters mol2_path : str Path to the multi-mol2 file. Parses gzip files if the filepath ends on .gz. Returns A generator object for lists for every extracted mol2-file. Lists contain the molecule ID and the mol2 file contents. e.g., ['ID1234', ['@ MOLECULE\\n', '...']]. Note that bytestrings are returned (for reasons of efficieny) if the Mol2 content is read from a gzip (.gz) file.","title":"split_multimol2"},{"location":"api_modules/biopandas.pdb/PandasPdb/","text":"PandasPdb PandasPdb() Object for working with Protein Databank structure files. Attributes df : dict Dictionary storing pandas DataFrames for PDB record sections. The dictionary keys are {'ATOM', 'HETATM', 'ANISOU', 'OTHERS'} where 'OTHERS' contains all entries that are not parsed as 'ATOM', 'HETATM', or 'ANISOU'. pdb_text : str PDB file contents in raw text format. pdb_path : str Location of the PDB file that was read in via read_pdb or URL of the page where the PDB content was fetched from if fetch_pdb was called. header : str PDB file description. code : str PDB code Methods amino3to1(record='ATOM', residue_col='residue_name', fillna='?') Creates 1-letter amino acid codes from DataFrame Non-canonical amino-acids are converted as follows: ASH (protonated ASP) => D CYX (disulfide-bonded CYS) => C GLH (protonated GLU) => E HID/HIE/HIP (different protonation states of HIS) = H HYP (hydroxyproline) => P MSE (selenomethionine) => M Parameters record : str, default: 'ATOM' Specfies the record DataFrame. residue_col : str, default: 'residue_name' Column in record DataFrame to look for 3-letter amino acid codes for the conversion. fillna : str, default: '?' Placeholder string to use for unknown amino acids. Returns pandas.DataFrame : Pandas DataFrame object consisting of two columns, 'chain_id' and 'residue_name' , where the former contains the chain ID of the amino acid and the latter contains the 1-letter amino acid code, respectively. distance(xyz=(0.0, 0.0, 0.0), records=('ATOM', 'HETATM')) Computes Euclidean distance between atoms and a 3D point. Parameters xyz : tuple, default: (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation. records : iterable, default: ('ATOM', 'HETATM') Specify which record sections to consider. For example, to consider both protein and ligand atoms, set records=('ATOM', 'HETATM') . This setting is ignored if df is not set to None. For downward compatibility, a string argument is still supported but deprecated and will be removed in future versions. Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the record section and xyz . distance_df(df, xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms and a 3D point. Parameters df : DataFrame DataFrame containing entries in the PandasPdb.df['ATOM'] or PandasPdb.df['HETATM'] format for the the distance computation to the xyz reference coordinates. xyz : tuple, default: (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation. Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the record section and xyz . fetch_pdb(pdb_code) Fetches PDB file contents from the Protein Databank at rcsb.org. Parameters pdb_code : str A 4-letter PDB code, e.g., \"3eiy\". Returns self get(s, df=None, invert=False, records=('ATOM', 'HETATM')) Filter PDB DataFrames by properties Parameters s : str in {'main chain', 'hydrogen', 'c-alpha', 'heavy'} String to specify which entries to return. df : pandas.DataFrame, default: None Optional DataFrame to perform the filter operation on. If df=None, filters on self.df['ATOM']. invert : bool, default: True Inverts the search query. For example if s='hydrogen' and invert=True, all but hydrogen entries are returned. records : iterable, default: ('ATOM', 'HETATM') Specify which record sections to consider. For example, to consider both protein and ligand atoms, set records=('ATOM', 'HETATM') . This setting is ignored if df is not set to None. For downward compatibility, a string argument is still supported but deprecated and will be removed in future versions. Returns df : pandas.DataFrame Returns a DataFrame view on the filtered entries. impute_element(records=('ATOM', 'HETATM'), inplace=False) Impute element_symbol from atom_name section. Parameters records : iterable, default: ('ATOM', 'HETATM') Coordinate sections for which the element symbols should be imputed. inplace : bool, (default: False Performs the operation in-place if True and returns a copy of the PDB DataFrame otherwise. Returns DataFrame parse_sse() Parse secondary structure elements read_pdb(path) Read PDB files (unzipped or gzipped) from local drive Attributes path : str Path to the PDB file in .pdb format or gzipped format (.pdb.gz). Returns self rmsd(df1, df2, s=None, invert=False) Compute the Root Mean Square Deviation between molecules. Parameters df1 : pandas.DataFrame DataFrame with HETATM, ATOM, and/or ANISOU entries. df2 : pandas.DataFrame Second DataFrame for RMSD computation against df1. Must have the same number of entries as df1. s : {'main chain', 'hydrogen', 'c-alpha', 'heavy', 'carbon'} or None, default: None String to specify which entries to consider. If None, considers all atoms for comparison. invert : bool, default: False Inverts the string query if true. For example, the setting s='hydrogen', invert=True computes the RMSD based on all but hydrogen atoms. Returns rmsd : float Root Mean Square Deviation between df1 and df2 to_pdb(path, records=None, gz=False, append_newline=True) Write record DataFrames to a PDB file or gzipped PDB file. Parameters path : str A valid output path for the pdb file records : iterable, default: None A list of PDB record sections in {'ATOM', 'HETATM', 'ANISOU', 'OTHERS'} that are to be written. Writes all lines to PDB if records=None . gz : bool, default: False Writes a gzipped PDB file if True. append_newline : bool, default: True Appends a new line at the end of the PDB file if True Properties df Acccess dictionary of pandas DataFrames for PDB record sections.","title":"PandasPdb"},{"location":"api_modules/biopandas.pdb/PandasPdb/#pandaspdb","text":"PandasPdb() Object for working with Protein Databank structure files. Attributes df : dict Dictionary storing pandas DataFrames for PDB record sections. The dictionary keys are {'ATOM', 'HETATM', 'ANISOU', 'OTHERS'} where 'OTHERS' contains all entries that are not parsed as 'ATOM', 'HETATM', or 'ANISOU'. pdb_text : str PDB file contents in raw text format. pdb_path : str Location of the PDB file that was read in via read_pdb or URL of the page where the PDB content was fetched from if fetch_pdb was called. header : str PDB file description. code : str PDB code","title":"PandasPdb"},{"location":"api_modules/biopandas.pdb/PandasPdb/#methods","text":"amino3to1(record='ATOM', residue_col='residue_name', fillna='?') Creates 1-letter amino acid codes from DataFrame Non-canonical amino-acids are converted as follows: ASH (protonated ASP) => D CYX (disulfide-bonded CYS) => C GLH (protonated GLU) => E HID/HIE/HIP (different protonation states of HIS) = H HYP (hydroxyproline) => P MSE (selenomethionine) => M Parameters record : str, default: 'ATOM' Specfies the record DataFrame. residue_col : str, default: 'residue_name' Column in record DataFrame to look for 3-letter amino acid codes for the conversion. fillna : str, default: '?' Placeholder string to use for unknown amino acids. Returns pandas.DataFrame : Pandas DataFrame object consisting of two columns, 'chain_id' and 'residue_name' , where the former contains the chain ID of the amino acid and the latter contains the 1-letter amino acid code, respectively. distance(xyz=(0.0, 0.0, 0.0), records=('ATOM', 'HETATM')) Computes Euclidean distance between atoms and a 3D point. Parameters xyz : tuple, default: (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation. records : iterable, default: ('ATOM', 'HETATM') Specify which record sections to consider. For example, to consider both protein and ligand atoms, set records=('ATOM', 'HETATM') . This setting is ignored if df is not set to None. For downward compatibility, a string argument is still supported but deprecated and will be removed in future versions. Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the record section and xyz . distance_df(df, xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms and a 3D point. Parameters df : DataFrame DataFrame containing entries in the PandasPdb.df['ATOM'] or PandasPdb.df['HETATM'] format for the the distance computation to the xyz reference coordinates. xyz : tuple, default: (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation. Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the record section and xyz . fetch_pdb(pdb_code) Fetches PDB file contents from the Protein Databank at rcsb.org. Parameters pdb_code : str A 4-letter PDB code, e.g., \"3eiy\". Returns self get(s, df=None, invert=False, records=('ATOM', 'HETATM')) Filter PDB DataFrames by properties Parameters s : str in {'main chain', 'hydrogen', 'c-alpha', 'heavy'} String to specify which entries to return. df : pandas.DataFrame, default: None Optional DataFrame to perform the filter operation on. If df=None, filters on self.df['ATOM']. invert : bool, default: True Inverts the search query. For example if s='hydrogen' and invert=True, all but hydrogen entries are returned. records : iterable, default: ('ATOM', 'HETATM') Specify which record sections to consider. For example, to consider both protein and ligand atoms, set records=('ATOM', 'HETATM') . This setting is ignored if df is not set to None. For downward compatibility, a string argument is still supported but deprecated and will be removed in future versions. Returns df : pandas.DataFrame Returns a DataFrame view on the filtered entries. impute_element(records=('ATOM', 'HETATM'), inplace=False) Impute element_symbol from atom_name section. Parameters records : iterable, default: ('ATOM', 'HETATM') Coordinate sections for which the element symbols should be imputed. inplace : bool, (default: False Performs the operation in-place if True and returns a copy of the PDB DataFrame otherwise. Returns DataFrame parse_sse() Parse secondary structure elements read_pdb(path) Read PDB files (unzipped or gzipped) from local drive Attributes path : str Path to the PDB file in .pdb format or gzipped format (.pdb.gz). Returns self rmsd(df1, df2, s=None, invert=False) Compute the Root Mean Square Deviation between molecules. Parameters df1 : pandas.DataFrame DataFrame with HETATM, ATOM, and/or ANISOU entries. df2 : pandas.DataFrame Second DataFrame for RMSD computation against df1. Must have the same number of entries as df1. s : {'main chain', 'hydrogen', 'c-alpha', 'heavy', 'carbon'} or None, default: None String to specify which entries to consider. If None, considers all atoms for comparison. invert : bool, default: False Inverts the string query if true. For example, the setting s='hydrogen', invert=True computes the RMSD based on all but hydrogen atoms. Returns rmsd : float Root Mean Square Deviation between df1 and df2 to_pdb(path, records=None, gz=False, append_newline=True) Write record DataFrames to a PDB file or gzipped PDB file. Parameters path : str A valid output path for the pdb file records : iterable, default: None A list of PDB record sections in {'ATOM', 'HETATM', 'ANISOU', 'OTHERS'} that are to be written. Writes all lines to PDB if records=None . gz : bool, default: False Writes a gzipped PDB file if True. append_newline : bool, default: True Appends a new line at the end of the PDB file if True","title":"Methods"},{"location":"api_modules/biopandas.pdb/PandasPdb/#properties","text":"df Acccess dictionary of pandas DataFrames for PDB record sections.","title":"Properties"},{"location":"api_modules/biopandas.testutils/assert_raises/","text":"assert_raises assert_raises(exception_type, message, func, args, * kwargs) Check that an exception is raised with a specific message Parameters exception_type : exception The exception that should be raised message : str (default: None) The error message that should be raised. Ignored if False or None func : callable The function that raises the exception *args : positional arguments to func **kwargs : keyword arguments to func","title":"Assert raises"},{"location":"api_modules/biopandas.testutils/assert_raises/#assert_raises","text":"assert_raises(exception_type, message, func, args, * kwargs) Check that an exception is raised with a specific message Parameters exception_type : exception The exception that should be raised message : str (default: None) The error message that should be raised. Ignored if False or None func : callable The function that raises the exception *args : positional arguments to func **kwargs : keyword arguments to func","title":"assert_raises"},{"location":"api_subpackages/biopandas.mol2/","text":"biopandas version: 0.2.5 PandasMol2 PandasMol2() Object for working with Tripos Mol2 structure files. Attributes df : pandas.DataFrame DataFrame of a Mol2's ATOM section mol2_text : str Mol2 file contents in string format code : str ID, code, or name of the molecule stored pdb_path : str Location of the MOL2 file that was read in via read_mol2 Methods distance(xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms in self.df and a 3D point. Parameters xyz : tuple (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the atom section and xyz . distance_df(df, xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms and a 3D point. Parameters df : DataFrame DataFrame containing entries similar to the PandasMol2.df format for the the distance computation to the xyz reference coordinates. xyz : tuple (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the atom section and xyz . read_mol2(path, columns=None) Reads Mol2 files (unzipped or gzipped) from local drive Note that if your mol2 file contains more than one molecule, only the first molecule is loaded into the DataFrame Attributes path : str Path to the Mol2 file in .mol2 format or gzipped format (.mol2.gz) columns : dict or None (default: None) If None, this methods expects a 9-column ATOM section that contains the following columns: {0:('atom_id', int), 1:('atom_name', str), 2:('x', float), 3:('y', float), 4:('z', float), 5:('atom_type', str), 6:('subst_id', int), 7:('subst_name', str), 8:('charge', float)} If your Mol2 files are formatted differently, you can provide your own column_mapping dictionary in a format similar to the one above. However, note that not all assert_raise_message methods may be supported then. Returns self read_mol2_from_list(mol2_lines, mol2_code, columns=None) Reads Mol2 file from a list into DataFrames Attributes mol2_lines : list A list of lines containing the mol2 file contents. For example, ['@ MOLECULE\\n', 'ZINC38611810\\n', ' 65 68 0 0 0\\n', 'SMALL\\n', 'NO_CHARGES\\n', '\\n', '@ ATOM\\n', ' 1 C1 -1.1786 2.7011 -4.0323 C.3 1 <0> -0.1537\\n', ' 2 C2 -1.2950 1.2442 -3.5798 C.3 1 <0> -0.1156\\n', ...] mol2_code : str or None Name or ID of the molecule. columns : dict or None (default: None) If None, this methods expects a 9-column ATOM section that contains the following columns: {0:('atom_id', int), 1:('atom_name', str), 2:('x', float), 3:('y', float), 4:('z', float), 5:('atom_type', str), 6:('subst_id', int), 7:('subst_name', str), 8:('charge', float)} If your Mol2 files are formatted differently, you can provide your own column_mapping dictionary in a format similar to the one above. However, note that not all assert_raise_message methods may be supported then. Returns self rmsd(df1, df2, heavy_only=True) Compute the Root Mean Square Deviation between molecules Parameters df1 : pandas.DataFrame DataFrame with HETATM, ATOM, and/or ANISOU entries df2 : pandas.DataFrame Second DataFrame for RMSD computation against df1. Must have the same number of entries as df1 heavy_only : bool (default: True) Which atoms to compare to compute the RMSD. If True (default), computes the RMSD between non-hydrogen atoms only. Returns rmsd : float Root Mean Square Deviation between df1 and df2 Properties df Acccesses the pandas DataFrame split_multimol2 split_multimol2(mol2_path) Splits a multi-mol2 file into individual Mol2 file contents. Parameters mol2_path : str Path to the multi-mol2 file. Parses gzip files if the filepath ends on .gz. Returns A generator object for lists for every extracted mol2-file. Lists contain the molecule ID and the mol2 file contents. e.g., ['ID1234', ['@ MOLECULE\\n', '...']]. Note that bytestrings are returned (for reasons of efficieny) if the Mol2 content is read from a gzip (.gz) file.","title":"biopandas.mol2"},{"location":"api_subpackages/biopandas.mol2/#pandasmol2","text":"PandasMol2() Object for working with Tripos Mol2 structure files. Attributes df : pandas.DataFrame DataFrame of a Mol2's ATOM section mol2_text : str Mol2 file contents in string format code : str ID, code, or name of the molecule stored pdb_path : str Location of the MOL2 file that was read in via read_mol2","title":"PandasMol2"},{"location":"api_subpackages/biopandas.mol2/#methods","text":"distance(xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms in self.df and a 3D point. Parameters xyz : tuple (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the atom section and xyz . distance_df(df, xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms and a 3D point. Parameters df : DataFrame DataFrame containing entries similar to the PandasMol2.df format for the the distance computation to the xyz reference coordinates. xyz : tuple (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the atom section and xyz . read_mol2(path, columns=None) Reads Mol2 files (unzipped or gzipped) from local drive Note that if your mol2 file contains more than one molecule, only the first molecule is loaded into the DataFrame Attributes path : str Path to the Mol2 file in .mol2 format or gzipped format (.mol2.gz) columns : dict or None (default: None) If None, this methods expects a 9-column ATOM section that contains the following columns: {0:('atom_id', int), 1:('atom_name', str), 2:('x', float), 3:('y', float), 4:('z', float), 5:('atom_type', str), 6:('subst_id', int), 7:('subst_name', str), 8:('charge', float)} If your Mol2 files are formatted differently, you can provide your own column_mapping dictionary in a format similar to the one above. However, note that not all assert_raise_message methods may be supported then. Returns self read_mol2_from_list(mol2_lines, mol2_code, columns=None) Reads Mol2 file from a list into DataFrames Attributes mol2_lines : list A list of lines containing the mol2 file contents. For example, ['@ MOLECULE\\n', 'ZINC38611810\\n', ' 65 68 0 0 0\\n', 'SMALL\\n', 'NO_CHARGES\\n', '\\n', '@ ATOM\\n', ' 1 C1 -1.1786 2.7011 -4.0323 C.3 1 <0> -0.1537\\n', ' 2 C2 -1.2950 1.2442 -3.5798 C.3 1 <0> -0.1156\\n', ...] mol2_code : str or None Name or ID of the molecule. columns : dict or None (default: None) If None, this methods expects a 9-column ATOM section that contains the following columns: {0:('atom_id', int), 1:('atom_name', str), 2:('x', float), 3:('y', float), 4:('z', float), 5:('atom_type', str), 6:('subst_id', int), 7:('subst_name', str), 8:('charge', float)} If your Mol2 files are formatted differently, you can provide your own column_mapping dictionary in a format similar to the one above. However, note that not all assert_raise_message methods may be supported then. Returns self rmsd(df1, df2, heavy_only=True) Compute the Root Mean Square Deviation between molecules Parameters df1 : pandas.DataFrame DataFrame with HETATM, ATOM, and/or ANISOU entries df2 : pandas.DataFrame Second DataFrame for RMSD computation against df1. Must have the same number of entries as df1 heavy_only : bool (default: True) Which atoms to compare to compute the RMSD. If True (default), computes the RMSD between non-hydrogen atoms only. Returns rmsd : float Root Mean Square Deviation between df1 and df2","title":"Methods"},{"location":"api_subpackages/biopandas.mol2/#properties","text":"df Acccesses the pandas DataFrame","title":"Properties"},{"location":"api_subpackages/biopandas.mol2/#split_multimol2","text":"split_multimol2(mol2_path) Splits a multi-mol2 file into individual Mol2 file contents. Parameters mol2_path : str Path to the multi-mol2 file. Parses gzip files if the filepath ends on .gz. Returns A generator object for lists for every extracted mol2-file. Lists contain the molecule ID and the mol2 file contents. e.g., ['ID1234', ['@ MOLECULE\\n', '...']]. Note that bytestrings are returned (for reasons of efficieny) if the Mol2 content is read from a gzip (.gz) file.","title":"split_multimol2"},{"location":"api_subpackages/biopandas.pdb/","text":"biopandas version: 0.2.5 PandasPdb PandasPdb() Object for working with Protein Databank structure files. Attributes df : dict Dictionary storing pandas DataFrames for PDB record sections. The dictionary keys are {'ATOM', 'HETATM', 'ANISOU', 'OTHERS'} where 'OTHERS' contains all entries that are not parsed as 'ATOM', 'HETATM', or 'ANISOU'. pdb_text : str PDB file contents in raw text format. pdb_path : str Location of the PDB file that was read in via read_pdb or URL of the page where the PDB content was fetched from if fetch_pdb was called. header : str PDB file description. code : str PDB code Methods amino3to1(record='ATOM', residue_col='residue_name', fillna='?') Creates 1-letter amino acid codes from DataFrame Non-canonical amino-acids are converted as follows: ASH (protonated ASP) => D CYX (disulfide-bonded CYS) => C GLH (protonated GLU) => E HID/HIE/HIP (different protonation states of HIS) = H HYP (hydroxyproline) => P MSE (selenomethionine) => M Parameters record : str, default: 'ATOM' Specfies the record DataFrame. residue_col : str, default: 'residue_name' Column in record DataFrame to look for 3-letter amino acid codes for the conversion. fillna : str, default: '?' Placeholder string to use for unknown amino acids. Returns pandas.DataFrame : Pandas DataFrame object consisting of two columns, 'chain_id' and 'residue_name' , where the former contains the chain ID of the amino acid and the latter contains the 1-letter amino acid code, respectively. distance(xyz=(0.0, 0.0, 0.0), records=('ATOM', 'HETATM')) Computes Euclidean distance between atoms and a 3D point. Parameters xyz : tuple, default: (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation. records : iterable, default: ('ATOM', 'HETATM') Specify which record sections to consider. For example, to consider both protein and ligand atoms, set records=('ATOM', 'HETATM') . This setting is ignored if df is not set to None. For downward compatibility, a string argument is still supported but deprecated and will be removed in future versions. Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the record section and xyz . distance_df(df, xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms and a 3D point. Parameters df : DataFrame DataFrame containing entries in the PandasPdb.df['ATOM'] or PandasPdb.df['HETATM'] format for the the distance computation to the xyz reference coordinates. xyz : tuple, default: (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation. Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the record section and xyz . fetch_pdb(pdb_code) Fetches PDB file contents from the Protein Databank at rcsb.org. Parameters pdb_code : str A 4-letter PDB code, e.g., \"3eiy\". Returns self get(s, df=None, invert=False, records=('ATOM', 'HETATM')) Filter PDB DataFrames by properties Parameters s : str in {'main chain', 'hydrogen', 'c-alpha', 'heavy'} String to specify which entries to return. df : pandas.DataFrame, default: None Optional DataFrame to perform the filter operation on. If df=None, filters on self.df['ATOM']. invert : bool, default: True Inverts the search query. For example if s='hydrogen' and invert=True, all but hydrogen entries are returned. records : iterable, default: ('ATOM', 'HETATM') Specify which record sections to consider. For example, to consider both protein and ligand atoms, set records=('ATOM', 'HETATM') . This setting is ignored if df is not set to None. For downward compatibility, a string argument is still supported but deprecated and will be removed in future versions. Returns df : pandas.DataFrame Returns a DataFrame view on the filtered entries. impute_element(records=('ATOM', 'HETATM'), inplace=False) Impute element_symbol from atom_name section. Parameters records : iterable, default: ('ATOM', 'HETATM') Coordinate sections for which the element symbols should be imputed. inplace : bool, (default: False Performs the operation in-place if True and returns a copy of the PDB DataFrame otherwise. Returns DataFrame parse_sse() Parse secondary structure elements read_pdb(path) Read PDB files (unzipped or gzipped) from local drive Attributes path : str Path to the PDB file in .pdb format or gzipped format (.pdb.gz). Returns self rmsd(df1, df2, s=None, invert=False) Compute the Root Mean Square Deviation between molecules. Parameters df1 : pandas.DataFrame DataFrame with HETATM, ATOM, and/or ANISOU entries. df2 : pandas.DataFrame Second DataFrame for RMSD computation against df1. Must have the same number of entries as df1. s : {'main chain', 'hydrogen', 'c-alpha', 'heavy', 'carbon'} or None, default: None String to specify which entries to consider. If None, considers all atoms for comparison. invert : bool, default: False Inverts the string query if true. For example, the setting s='hydrogen', invert=True computes the RMSD based on all but hydrogen atoms. Returns rmsd : float Root Mean Square Deviation between df1 and df2 to_pdb(path, records=None, gz=False, append_newline=True) Write record DataFrames to a PDB file or gzipped PDB file. Parameters path : str A valid output path for the pdb file records : iterable, default: None A list of PDB record sections in {'ATOM', 'HETATM', 'ANISOU', 'OTHERS'} that are to be written. Writes all lines to PDB if records=None . gz : bool, default: False Writes a gzipped PDB file if True. append_newline : bool, default: True Appends a new line at the end of the PDB file if True Properties df Acccess dictionary of pandas DataFrames for PDB record sections.","title":"biopandas.pdb"},{"location":"api_subpackages/biopandas.pdb/#pandaspdb","text":"PandasPdb() Object for working with Protein Databank structure files. Attributes df : dict Dictionary storing pandas DataFrames for PDB record sections. The dictionary keys are {'ATOM', 'HETATM', 'ANISOU', 'OTHERS'} where 'OTHERS' contains all entries that are not parsed as 'ATOM', 'HETATM', or 'ANISOU'. pdb_text : str PDB file contents in raw text format. pdb_path : str Location of the PDB file that was read in via read_pdb or URL of the page where the PDB content was fetched from if fetch_pdb was called. header : str PDB file description. code : str PDB code","title":"PandasPdb"},{"location":"api_subpackages/biopandas.pdb/#methods","text":"amino3to1(record='ATOM', residue_col='residue_name', fillna='?') Creates 1-letter amino acid codes from DataFrame Non-canonical amino-acids are converted as follows: ASH (protonated ASP) => D CYX (disulfide-bonded CYS) => C GLH (protonated GLU) => E HID/HIE/HIP (different protonation states of HIS) = H HYP (hydroxyproline) => P MSE (selenomethionine) => M Parameters record : str, default: 'ATOM' Specfies the record DataFrame. residue_col : str, default: 'residue_name' Column in record DataFrame to look for 3-letter amino acid codes for the conversion. fillna : str, default: '?' Placeholder string to use for unknown amino acids. Returns pandas.DataFrame : Pandas DataFrame object consisting of two columns, 'chain_id' and 'residue_name' , where the former contains the chain ID of the amino acid and the latter contains the 1-letter amino acid code, respectively. distance(xyz=(0.0, 0.0, 0.0), records=('ATOM', 'HETATM')) Computes Euclidean distance between atoms and a 3D point. Parameters xyz : tuple, default: (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation. records : iterable, default: ('ATOM', 'HETATM') Specify which record sections to consider. For example, to consider both protein and ligand atoms, set records=('ATOM', 'HETATM') . This setting is ignored if df is not set to None. For downward compatibility, a string argument is still supported but deprecated and will be removed in future versions. Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the record section and xyz . distance_df(df, xyz=(0.0, 0.0, 0.0)) Computes Euclidean distance between atoms and a 3D point. Parameters df : DataFrame DataFrame containing entries in the PandasPdb.df['ATOM'] or PandasPdb.df['HETATM'] format for the the distance computation to the xyz reference coordinates. xyz : tuple, default: (0.00, 0.00, 0.00) X, Y, and Z coordinate of the reference center for the distance computation. Returns pandas.Series : Pandas Series object containing the Euclidean distance between the atoms in the record section and xyz . fetch_pdb(pdb_code) Fetches PDB file contents from the Protein Databank at rcsb.org. Parameters pdb_code : str A 4-letter PDB code, e.g., \"3eiy\". Returns self get(s, df=None, invert=False, records=('ATOM', 'HETATM')) Filter PDB DataFrames by properties Parameters s : str in {'main chain', 'hydrogen', 'c-alpha', 'heavy'} String to specify which entries to return. df : pandas.DataFrame, default: None Optional DataFrame to perform the filter operation on. If df=None, filters on self.df['ATOM']. invert : bool, default: True Inverts the search query. For example if s='hydrogen' and invert=True, all but hydrogen entries are returned. records : iterable, default: ('ATOM', 'HETATM') Specify which record sections to consider. For example, to consider both protein and ligand atoms, set records=('ATOM', 'HETATM') . This setting is ignored if df is not set to None. For downward compatibility, a string argument is still supported but deprecated and will be removed in future versions. Returns df : pandas.DataFrame Returns a DataFrame view on the filtered entries. impute_element(records=('ATOM', 'HETATM'), inplace=False) Impute element_symbol from atom_name section. Parameters records : iterable, default: ('ATOM', 'HETATM') Coordinate sections for which the element symbols should be imputed. inplace : bool, (default: False Performs the operation in-place if True and returns a copy of the PDB DataFrame otherwise. Returns DataFrame parse_sse() Parse secondary structure elements read_pdb(path) Read PDB files (unzipped or gzipped) from local drive Attributes path : str Path to the PDB file in .pdb format or gzipped format (.pdb.gz). Returns self rmsd(df1, df2, s=None, invert=False) Compute the Root Mean Square Deviation between molecules. Parameters df1 : pandas.DataFrame DataFrame with HETATM, ATOM, and/or ANISOU entries. df2 : pandas.DataFrame Second DataFrame for RMSD computation against df1. Must have the same number of entries as df1. s : {'main chain', 'hydrogen', 'c-alpha', 'heavy', 'carbon'} or None, default: None String to specify which entries to consider. If None, considers all atoms for comparison. invert : bool, default: False Inverts the string query if true. For example, the setting s='hydrogen', invert=True computes the RMSD based on all but hydrogen atoms. Returns rmsd : float Root Mean Square Deviation between df1 and df2 to_pdb(path, records=None, gz=False, append_newline=True) Write record DataFrames to a PDB file or gzipped PDB file. Parameters path : str A valid output path for the pdb file records : iterable, default: None A list of PDB record sections in {'ATOM', 'HETATM', 'ANISOU', 'OTHERS'} that are to be written. Writes all lines to PDB if records=None . gz : bool, default: False Writes a gzipped PDB file if True. append_newline : bool, default: True Appends a new line at the end of the PDB file if True","title":"Methods"},{"location":"api_subpackages/biopandas.pdb/#properties","text":"df Acccess dictionary of pandas DataFrames for PDB record sections.","title":"Properties"},{"location":"api_subpackages/biopandas.testutils/","text":"biopandas version: 0.2.5 assert_raises assert_raises(exception_type, message, func, args, * kwargs) Check that an exception is raised with a specific message Parameters exception_type : exception The exception that should be raised message : str (default: None) The error message that should be raised. Ignored if False or None func : callable The function that raises the exception *args : positional arguments to func **kwargs : keyword arguments to func","title":"Biopandas.testutils"},{"location":"api_subpackages/biopandas.testutils/#assert_raises","text":"assert_raises(exception_type, message, func, args, * kwargs) Check that an exception is raised with a specific message Parameters exception_type : exception The exception that should be raised message : str (default: None) The error message that should be raised. Ignored if False or None func : callable The function that raises the exception *args : positional arguments to func **kwargs : keyword arguments to func","title":"assert_raises"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/","text":"Working with MOL2 Structures in DataFrames The Tripos MOL2 format is a common format for working with small molecules. In this tutorial, we will go over some examples that illustrate how we can use Biopandas' MOL2 DataFrames to analyze molecules conveniently. Loading MOL2 Files Using the read_mol2 method, we can read MOL2 files from standard .mol2 text files: from biopandas.mol2 import PandasMol2 pmol = PandasMol2().read_mol2('./data/1b5e_1.mol2') [File link: 1b5e_1.mol2 ] The read_mol2 method can also load structures from .mol2.gz files, but if you have a multi-mol2 file, keep in mind that it will only fetch the first molecule in this file. In the section \" Parsing Multi-MOL2 files ,\" we will see how we can parse files that contain multiple structures. pmol = PandasMol2().read_mol2('./data/40_mol2_files.mol2.gz') [File link: 40_mol2_files.mol2.gz ] After the file was succesfully loaded, we have access to the following basic PandasMol2 attributes: print('Molecule ID: %s' % pmol.code) print('\\nRaw MOL2 file contents:\\n\\n%s\\n...' % pmol.mol2_text[:500]) Molecule ID: ZINC38611810 Raw MOL2 file contents: @<TRIPOS>MOLECULE ZINC38611810 65 68 0 0 0 SMALL NO_CHARGES @<TRIPOS>ATOM 1 C1 -1.1786 2.7011 -4.0323 C.3 1 <0> -0.1537 2 C2 -1.2950 1.2442 -3.5798 C.3 1 <0> -0.1156 3 C3 -0.1742 0.4209 -4.2178 C.3 1 <0> -0.1141 4 C4 -0.2887 -1.0141 -3.7721 C.2 1 <0> 0.4504 5 O1 -1.1758 -1.3445 -3.0212 O.2 1 <0> -0.4896 6 O2 ... The most interesting and useful attribute, however, is the PandasMol2.df DataFrame, which contains the ATOM section of the MOL2 structure. Let's print the first 3 lines from the ATOM coordinate section to see how it looks like: pmol.df.head(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... atom_type subst_id subst_name charge 0 1 C1 -1.1786 2.7011 ... C.3 1 <0> -0.1537 1 2 C2 -1.2950 1.2442 ... C.3 1 <0> -0.1156 2 3 C3 -0.1742 0.4209 ... C.3 1 <0> -0.1141 3 rows \u00d7 9 columns The MOL2 Data Format PandasMol2 expects the MOL2 file to be in the standard Tripos MOL2 format, and most importantly, that the \"@ ATOM\" section is consistent with the following format convention: Format: atom_id atom_name x y z atom_type [subst_id [subst_name [charge [status_bit]]]] atom_id (integer) = the ID number of the atom at the time the file was created. This is provided for reference only and is not used when the .mol2 file is read into SYBYL. atom_name (string) = the name of the atom. x (real) = the x coordinate of the atom. y (real) = the y coordinate of the atom. z (real) = the z coordinate of the atom. atom_type (string) = the SYBYL atom type for the atom. subst_id (integer) = the ID number of the substructure containing the atom. subst_name (string) = the name of the substructure containing the atom. charge (real) = the charge associated with the atom. status_bit (string) = the internal SYBYL status bits associated with the atom. These should never be set by the user. Valid status bits are DSPMOD, TYPECOL, CAP, BACKBONE, DICT, ESSENTIAL, WATER and DIRECT. For example, the contents of a typical Tripos MOL2 file may look like this: @<TRIPOS>MOLECULE DCM Pose 1 32 33 0 0 0 SMALL USER_CHARGES @<TRIPOS>ATOM 1 C1 18.8934 5.5819 24.1747 C.2 1 <0> -0.1356 2 C2 18.1301 4.7642 24.8969 C.2 1 <0> -0.0410 3 C3 18.2645 6.8544 23.7342 C.2 1 <0> 0.4856 ... 31 H11 18.5977 8.5756 22.6932 H 1 <0> 0.4000 32 H12 14.2530 1.0535 27.4278 H 1 <0> 0.4000 @<TRIPOS>BOND 1 1 2 2 2 1 3 1 3 2 11 1 4 3 10 2 5 3 12 1 ... 28 8 27 1 29 9 28 1 30 9 29 1 31 12 30 1 32 12 31 1 33 18 32 1 Working with MOL2 DataFrames In the previous sections, we've seen how to load MOL2 structures into DataFrames and how to access them. Once, we have the ATOM section of a MOL2 file in a DataFrame format, we can readily slice and dice the molecular structure and analyze it. To demonstrate some typical use cases, let us load the structure of deoxycytidylate hydroxymethylase (DCM), which is shown in the figure below: from biopandas.mol2 import PandasMol2 pmol = PandasMol2() pmol.read_mol2('./data/1b5e_1.mol2') pmol.df.tail(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... atom_type subst_id subst_name charge 22 23 H3 15.8520 2.8983 ... H 1 <0> 0.0 23 24 H4 14.3405 3.3601 ... H 1 <0> 0.0 24 25 H5 15.3663 0.9351 ... H 1 <0> 0.0 25 26 H6 16.6681 1.6130 ... H 1 <0> 0.0 26 27 H7 15.3483 4.6961 ... H 1 <0> 0.0 27 28 H8 18.8490 1.8078 ... H 1 <0> 0.0 28 29 H9 17.8303 1.5497 ... H 1 <0> 0.0 29 30 H10 19.9527 7.4708 ... H 1 <0> 0.4 30 31 H11 18.5977 8.5756 ... H 1 <0> 0.4 31 32 H12 14.2530 1.0535 ... H 1 <0> 0.4 10 rows \u00d7 9 columns [File link: 1b5e_1.mol2 ] For example, we can select all hydrogen atoms by filtering on the atom type column: pmol.df[pmol.df['atom_type'] != 'H'].tail(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... atom_type subst_id subst_name charge 10 11 N2 16.8196 5.0644 ... N.am 1 <0> -0.4691 11 12 N3 19.0194 7.7275 ... N.pl3 1 <0> -0.8500 12 13 O1 18.7676 -2.3524 ... O.3 1 <0> -1.0333 13 14 O2 20.3972 -0.3812 ... O.3 1 <0> -1.0333 14 15 O3 15.0888 6.5824 ... O.2 1 <0> -0.5700 15 16 O4 18.9314 -0.7527 ... O.2 1 <0> -1.0333 16 17 O5 16.9690 3.4315 ... O.3 1 <0> -0.5600 17 18 O6 14.3223 1.8946 ... O.3 1 <0> -0.6800 18 19 O7 17.9091 -0.0135 ... O.3 1 <0> -0.5512 19 20 P1 19.0969 -0.9440 ... P.3 1 <0> 1.3712 10 rows \u00d7 9 columns Or, if we like to count the number of keto-groups in this molecule, we can do the following: keto = pmol.df[pmol.df['atom_type'] == 'O.2'] print('number of keto groups: %d' % keto.shape[0]) keto number of keto groups: 2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... atom_type subst_id subst_name charge 14 15 O3 15.0888 6.5824 ... O.2 1 <0> -0.5700 15 16 O4 18.9314 -0.7527 ... O.2 1 <0> -1.0333 2 rows \u00d7 9 columns A list of all the allowed atom types that can be found in Tripos MOL2 files is provided below: Code Definition C.3 carbon sp3 C.2 carbon sp2 C.1 carbon sp C.ar carbon aromatic C.cat cabocation (C+) used only in a guadinium group N.3 nitrogen sp3 N.2 nitrogen sp2 N.1 nitrogen sp N.ar nitrogen aromatic N.am nitrogen amide N.pl3 nitrogen trigonal planar N.4 nitrogen sp3 positively charged O.3 oxygen sp3 O.2 oxygen sp2 O.co2 oxygen in carboxylate and phosphate groups O.spc oxygen in Single Point Charge (SPC) water model O.t3p oxygen in Transferable Intermolecular Potential (TIP3P) water model S.3 sulfur sp3 S.2 sulfur sp2 S.O sulfoxide sulfur S.O2/S.o2 sulfone sulfur P.3 phosphorous sp3 F fluorine H hydrogen H.spc hydrogen in Single Point Charge (SPC) water model H.t3p hydrogen in Transferable Intermolecular Potential (TIP3P) water model LP lone pair Du dummy atom Du.C dummy carbon Any any atom Hal halogen Het heteroatom = N, O, S, P Hev heavy atom (non hydrogen) Li lithium Na sodium Mg magnesium Al aluminum Si silicon K potassium Ca calcium Cr.thm chromium (tetrahedral) Cr.oh chromium (octahedral) Mn manganese Fe iron Co.oh cobalt (octahedral) Cu copper Plotting Since we are using pandas under the hood, which in turns uses matplotlib under the hood, we can produce quick summary plots of our MOL2 structures conveniently. Below are a few examples of how to visualize molecular properties. from biopandas.mol2 import PandasMol2 pmol = PandasMol2().read_mol2('./data/1b5e_1.mol2') [File link: 1b5e_1.mol2 ] %matplotlib inline import matplotlib.pyplot as plt from matplotlib import style style.use('ggplot') For instance, let's say we are interested in the counts of the different atom types that can be found in the MOL2 file; we could do the following: pmol.df['atom_type'].value_counts().plot(kind='bar') plt.xlabel('atom type') plt.ylabel('count') plt.show() If this is too fine-grained for our needs, we could summarize the different atom types by atomic elements: pmol.df['element_type'] = pmol.df['atom_type'].apply(lambda x: x.split('.')[0]) pmol.df['element_type'].value_counts().plot(kind='bar') plt.xlabel('element type') plt.ylabel('count') plt.show() One of the coolest features in pandas is the groupby method. Below is an example plotting the average charge of the different atom types with the standard deviation as error bars: groupby_charge = pmol.df.groupby(['atom_type'])['charge'] groupby_charge.mean().plot(kind='bar', yerr=groupby_charge.std()) plt.ylabel('charge') plt.show() Computing the Root Mean Square Deviation The Root-mean-square deviation (RMSD) is simply a measure of the average distance between atoms of 2 structures. This calculation of the Cartesian error follows the equation: RMSD(a, b) = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} \\big((a_{ix})^2 + (a_{iy})^2 + (a_{iz})^2 \\big)} \\\\ = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} || a_i + b_i||_2^2} So, assuming that the we have the following 2 conformations of a ligand molecule we can compute the RMSD as follows: from biopandas.mol2 import PandasMol2 l_1 = PandasMol2().read_mol2('./data/1b5e_1.mol2') l_2 = PandasMol2().read_mol2('./data/1b5e_2.mol2') r_heavy = PandasMol2.rmsd(l_1.df, l_2.df) r_all = PandasMol2.rmsd(l_1.df, l_2.df, heavy_only=False) print('Heavy-atom RMSD: %.4f Angstrom' % r_heavy) print('All-atom RMSD: %.4f Angstrom' % r_all) Heavy-atom RMSD: 1.1609 Angstrom All-atom RMSD: 1.5523 Angstrom [File links: 1b5e_1.mol2 , 1b5e_2.mol2 ] Filtering Atoms by Distance We can use the distance method to compute the distance between each atom (or a subset of atoms) in our data frame and a three-dimensional reference point. For example, let's assume were are interested in computing the distance between a keto group in the DMC molecule, which we've seen earlier, and other atoms in the same molecule. First, let's get the coordinates of all keto-groups in this molecule: from biopandas.mol2 import PandasMol2 pmol = PandasMol2().read_mol2('./data/1b5e_1.mol2') keto_coord = pmol.df[pmol.df['atom_type'] == 'O.2'][['x', 'y', 'z']] keto_coord .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } x y z 14 15.0888 6.5824 25.0727 15 18.9314 -0.7527 24.1606 In the following example, we use PandasMol2 's distance method. The distance method returns a pandas Series object containing the Euclidean distance between an atom and all other atoms in the structure. In the following example, keto_coord.values[0] refers to the x, y, z coordinates of the first row (i.e., first keto group) in the array above: print('x, y, z coords:', keto_coord.values[0]) distances = pmol.distance(keto_coord.values[0]) x, y, z coords: [15.0888 6.5824 25.0727] For our convenience, we can add these distances to our MOL2 DataFrame: pmol.df['distances'] = distances pmol.df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... subst_id subst_name charge distances 0 1 C1 18.8934 5.5819 ... 1 <0> -0.1356 4.035144 1 2 C2 18.1301 4.7642 ... 1 <0> -0.0410 3.547712 2 3 C3 18.2645 6.8544 ... 1 <0> 0.4856 3.456969 3 4 C4 16.2520 6.2866 ... 1 <0> 0.8410 1.232313 4 5 C5 15.3820 3.0682 ... 1 <0> 0.0000 3.527546 5 rows \u00d7 10 columns Now, say we are interested in the Euclidean distance between the two keto groups in the molecule: pmol.df[pmol.df['atom_type'] == 'O.2'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... subst_id subst_name charge distances 14 15 O3 15.0888 6.5824 ... 1 <0> -0.5700 0.000000 15 16 O4 18.9314 -0.7527 ... 1 <0> -1.0333 8.330738 2 rows \u00d7 10 columns In the example above, the distance between the two keto groups is 8 angstrom. Another common task that we can perform using these atomic distances is to select only the neighboring atoms of the keto group (here: atoms within 3 angstrom). The code is as follows: all_within_3A = pmol.df[pmol.df['distances'] <= 3.0] all_within_3A.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... subst_id subst_name charge distances 7 8 C8 16.0764 4.1199 ... 1 <0> 0.5801 2.814490 9 10 N1 17.0289 7.1510 ... 1 <0> -0.6610 2.269690 10 11 N2 16.8196 5.0644 ... 1 <0> -0.4691 2.307553 14 15 O3 15.0888 6.5824 ... 1 <0> -0.5700 0.000000 26 27 H7 15.3483 4.6961 ... 1 <0> 0.0000 2.446817 5 rows \u00d7 10 columns Parsing Multi-MOL2 files Basic Multi-MOL2 File Parsing As mentioned earlier, PandasMol2.read_mol2 method only reads in the first molecule if it is given a multi-MOL2 file. However, if we want to create DataFrames from multiple structures in a MOL2 file, we can use the handy split_multimol2 generator. The split_multimol2 generator yields tuples containing the molecule IDs and the MOL2 content as strings in a list -- each line in the MOL2 file is stored as a string in the list. from biopandas.mol2 import split_multimol2 mol2_id, mol2_cont = next(split_multimol2('./data/40_mol2_files.mol2')) print('Molecule ID:\\n', mol2_id) print('First 10 lines:\\n', mol2_cont[:10]) Molecule ID: ZINC38611810 First 10 lines: ['@<TRIPOS>MOLECULE\\n', 'ZINC38611810\\n', ' 65 68 0 0 0\\n', 'SMALL\\n', 'NO_CHARGES\\n', '\\n', '@<TRIPOS>ATOM\\n', ' 1 C1 -1.1786 2.7011 -4.0323 C.3 1 <0> -0.1537\\n', ' 2 C2 -1.2950 1.2442 -3.5798 C.3 1 <0> -0.1156\\n', ' 3 C3 -0.1742 0.4209 -4.2178 C.3 1 <0> -0.1141\\n'] [File link: 40_mol2_files.mol2 ] We can now use this generator to loop over all files in a multi-MOL2 file and create PandasMol2 DataFrames. A typical use case would be the filtering of mol2 files by certain properties: pdmol = PandasMol2() with open('./data/filtered.mol2', 'w') as f: for mol2 in split_multimol2('./data/40_mol2_files.mol2'): pdmol.read_mol2_from_list(mol2_lines=mol2[1], mol2_code=mol2[0]) # do some analysis keep_molecule = False # save molecule if it passes our filter criterion if keep_molecule: # note that the mol2_text contains the original mol2 content f.write(pdmol.mol2_text) Using Multiprocessing for Multi-MOL2 File Analysis To improve the computational efficiency and throughput for multi-mol2 analyses, it is recommended to use the mputil package, which evaluates Python generators lazily. The lazy_imap function from mputil is based on Python's standardlib multiprocessing imap function, but it doesn't consume the generator upfront. This lazy evaluation is important, for example, if we are parsing large (possibly Gigabyte- or Terabyte-large) multi-mol2 files for multiprocessing. The following example provides a template for atom-type based molecule queries, but the data_processor function can be extended to do any kind of functional group queries (for example, involving the 'charge' column and/or PandasMol2.distance method). import pandas as pd from mputil import lazy_imap from biopandas.mol2 import PandasMol2 from biopandas.mol2 import split_multimol2 --------------------------------------------------------------------------- ModuleNotFoundError Traceback (most recent call last) <ipython-input-23-1a655249f2ec> in <module>() 1 import pandas as pd ----> 2 from mputil import lazy_imap 3 from biopandas.mol2 import PandasMol2 4 from biopandas.mol2 import split_multimol2 ModuleNotFoundError: No module named 'mputil' # Selection strings to capture # all molecules that contain at least one sp2 hybridized # oxygen atom and at least one Fluorine atom SELECTIONS = [\"(pdmol.df.atom_type == 'O.2')\", \"(pdmol.df.atom_type == 'F')\"] # Path to the multi-mol2 input file MOL2_FILE = \"./data/40_mol2_files.mol2\" # Data processing function to be run in parallel def data_processor(mol2): \"\"\"Return molecule ID if there's a match and '' otherwise\"\"\" pdmol = PandasMol2().read_mol2_from_list(mol2_lines=mol2[1], mol2_code=mol2[0]) match = mol2[0] for sub_sele in SELECTIONS: if not pd.eval(sub_sele).any(): match = '' break return match # Process molecules and save IDs of hits to disk with open('./data/selected_ids.txt', 'w') as f: searched, found = 0, 0 for chunk in lazy_imap(data_processor=data_processor, data_generator=split_multimol2(MOL2_FILE), n_cpus=0): # means all available cpus for mol2_id in chunk: if mol2_id: # write IDs of matching molecules to disk f.write('%s\\n' % mol2_id) found += 1 searched += len(chunk) print('Searched %d molecules. Got %d hits.' % (searched, found)) [Input File link: 40_mol2_files.mol2 ] [Output File link: selected_ids.txt ]","title":"Working with MOL2 Structures in DataFrames"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/#working-with-mol2-structures-in-dataframes","text":"The Tripos MOL2 format is a common format for working with small molecules. In this tutorial, we will go over some examples that illustrate how we can use Biopandas' MOL2 DataFrames to analyze molecules conveniently.","title":"Working with MOL2 Structures in DataFrames"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/#loading-mol2-files","text":"Using the read_mol2 method, we can read MOL2 files from standard .mol2 text files: from biopandas.mol2 import PandasMol2 pmol = PandasMol2().read_mol2('./data/1b5e_1.mol2') [File link: 1b5e_1.mol2 ] The read_mol2 method can also load structures from .mol2.gz files, but if you have a multi-mol2 file, keep in mind that it will only fetch the first molecule in this file. In the section \" Parsing Multi-MOL2 files ,\" we will see how we can parse files that contain multiple structures. pmol = PandasMol2().read_mol2('./data/40_mol2_files.mol2.gz') [File link: 40_mol2_files.mol2.gz ] After the file was succesfully loaded, we have access to the following basic PandasMol2 attributes: print('Molecule ID: %s' % pmol.code) print('\\nRaw MOL2 file contents:\\n\\n%s\\n...' % pmol.mol2_text[:500]) Molecule ID: ZINC38611810 Raw MOL2 file contents: @<TRIPOS>MOLECULE ZINC38611810 65 68 0 0 0 SMALL NO_CHARGES @<TRIPOS>ATOM 1 C1 -1.1786 2.7011 -4.0323 C.3 1 <0> -0.1537 2 C2 -1.2950 1.2442 -3.5798 C.3 1 <0> -0.1156 3 C3 -0.1742 0.4209 -4.2178 C.3 1 <0> -0.1141 4 C4 -0.2887 -1.0141 -3.7721 C.2 1 <0> 0.4504 5 O1 -1.1758 -1.3445 -3.0212 O.2 1 <0> -0.4896 6 O2 ... The most interesting and useful attribute, however, is the PandasMol2.df DataFrame, which contains the ATOM section of the MOL2 structure. Let's print the first 3 lines from the ATOM coordinate section to see how it looks like: pmol.df.head(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... atom_type subst_id subst_name charge 0 1 C1 -1.1786 2.7011 ... C.3 1 <0> -0.1537 1 2 C2 -1.2950 1.2442 ... C.3 1 <0> -0.1156 2 3 C3 -0.1742 0.4209 ... C.3 1 <0> -0.1141 3 rows \u00d7 9 columns","title":"Loading MOL2 Files"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/#the-mol2-data-format","text":"PandasMol2 expects the MOL2 file to be in the standard Tripos MOL2 format, and most importantly, that the \"@ ATOM\" section is consistent with the following format convention: Format: atom_id atom_name x y z atom_type [subst_id [subst_name [charge [status_bit]]]] atom_id (integer) = the ID number of the atom at the time the file was created. This is provided for reference only and is not used when the .mol2 file is read into SYBYL. atom_name (string) = the name of the atom. x (real) = the x coordinate of the atom. y (real) = the y coordinate of the atom. z (real) = the z coordinate of the atom. atom_type (string) = the SYBYL atom type for the atom. subst_id (integer) = the ID number of the substructure containing the atom. subst_name (string) = the name of the substructure containing the atom. charge (real) = the charge associated with the atom. status_bit (string) = the internal SYBYL status bits associated with the atom. These should never be set by the user. Valid status bits are DSPMOD, TYPECOL, CAP, BACKBONE, DICT, ESSENTIAL, WATER and DIRECT. For example, the contents of a typical Tripos MOL2 file may look like this: @<TRIPOS>MOLECULE DCM Pose 1 32 33 0 0 0 SMALL USER_CHARGES @<TRIPOS>ATOM 1 C1 18.8934 5.5819 24.1747 C.2 1 <0> -0.1356 2 C2 18.1301 4.7642 24.8969 C.2 1 <0> -0.0410 3 C3 18.2645 6.8544 23.7342 C.2 1 <0> 0.4856 ... 31 H11 18.5977 8.5756 22.6932 H 1 <0> 0.4000 32 H12 14.2530 1.0535 27.4278 H 1 <0> 0.4000 @<TRIPOS>BOND 1 1 2 2 2 1 3 1 3 2 11 1 4 3 10 2 5 3 12 1 ... 28 8 27 1 29 9 28 1 30 9 29 1 31 12 30 1 32 12 31 1 33 18 32 1","title":"The MOL2 Data Format"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/#working-with-mol2-dataframes","text":"In the previous sections, we've seen how to load MOL2 structures into DataFrames and how to access them. Once, we have the ATOM section of a MOL2 file in a DataFrame format, we can readily slice and dice the molecular structure and analyze it. To demonstrate some typical use cases, let us load the structure of deoxycytidylate hydroxymethylase (DCM), which is shown in the figure below: from biopandas.mol2 import PandasMol2 pmol = PandasMol2() pmol.read_mol2('./data/1b5e_1.mol2') pmol.df.tail(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... atom_type subst_id subst_name charge 22 23 H3 15.8520 2.8983 ... H 1 <0> 0.0 23 24 H4 14.3405 3.3601 ... H 1 <0> 0.0 24 25 H5 15.3663 0.9351 ... H 1 <0> 0.0 25 26 H6 16.6681 1.6130 ... H 1 <0> 0.0 26 27 H7 15.3483 4.6961 ... H 1 <0> 0.0 27 28 H8 18.8490 1.8078 ... H 1 <0> 0.0 28 29 H9 17.8303 1.5497 ... H 1 <0> 0.0 29 30 H10 19.9527 7.4708 ... H 1 <0> 0.4 30 31 H11 18.5977 8.5756 ... H 1 <0> 0.4 31 32 H12 14.2530 1.0535 ... H 1 <0> 0.4 10 rows \u00d7 9 columns [File link: 1b5e_1.mol2 ] For example, we can select all hydrogen atoms by filtering on the atom type column: pmol.df[pmol.df['atom_type'] != 'H'].tail(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... atom_type subst_id subst_name charge 10 11 N2 16.8196 5.0644 ... N.am 1 <0> -0.4691 11 12 N3 19.0194 7.7275 ... N.pl3 1 <0> -0.8500 12 13 O1 18.7676 -2.3524 ... O.3 1 <0> -1.0333 13 14 O2 20.3972 -0.3812 ... O.3 1 <0> -1.0333 14 15 O3 15.0888 6.5824 ... O.2 1 <0> -0.5700 15 16 O4 18.9314 -0.7527 ... O.2 1 <0> -1.0333 16 17 O5 16.9690 3.4315 ... O.3 1 <0> -0.5600 17 18 O6 14.3223 1.8946 ... O.3 1 <0> -0.6800 18 19 O7 17.9091 -0.0135 ... O.3 1 <0> -0.5512 19 20 P1 19.0969 -0.9440 ... P.3 1 <0> 1.3712 10 rows \u00d7 9 columns Or, if we like to count the number of keto-groups in this molecule, we can do the following: keto = pmol.df[pmol.df['atom_type'] == 'O.2'] print('number of keto groups: %d' % keto.shape[0]) keto number of keto groups: 2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... atom_type subst_id subst_name charge 14 15 O3 15.0888 6.5824 ... O.2 1 <0> -0.5700 15 16 O4 18.9314 -0.7527 ... O.2 1 <0> -1.0333 2 rows \u00d7 9 columns A list of all the allowed atom types that can be found in Tripos MOL2 files is provided below: Code Definition C.3 carbon sp3 C.2 carbon sp2 C.1 carbon sp C.ar carbon aromatic C.cat cabocation (C+) used only in a guadinium group N.3 nitrogen sp3 N.2 nitrogen sp2 N.1 nitrogen sp N.ar nitrogen aromatic N.am nitrogen amide N.pl3 nitrogen trigonal planar N.4 nitrogen sp3 positively charged O.3 oxygen sp3 O.2 oxygen sp2 O.co2 oxygen in carboxylate and phosphate groups O.spc oxygen in Single Point Charge (SPC) water model O.t3p oxygen in Transferable Intermolecular Potential (TIP3P) water model S.3 sulfur sp3 S.2 sulfur sp2 S.O sulfoxide sulfur S.O2/S.o2 sulfone sulfur P.3 phosphorous sp3 F fluorine H hydrogen H.spc hydrogen in Single Point Charge (SPC) water model H.t3p hydrogen in Transferable Intermolecular Potential (TIP3P) water model LP lone pair Du dummy atom Du.C dummy carbon Any any atom Hal halogen Het heteroatom = N, O, S, P Hev heavy atom (non hydrogen) Li lithium Na sodium Mg magnesium Al aluminum Si silicon K potassium Ca calcium Cr.thm chromium (tetrahedral) Cr.oh chromium (octahedral) Mn manganese Fe iron Co.oh cobalt (octahedral) Cu copper","title":"Working with MOL2 DataFrames"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/#plotting","text":"Since we are using pandas under the hood, which in turns uses matplotlib under the hood, we can produce quick summary plots of our MOL2 structures conveniently. Below are a few examples of how to visualize molecular properties. from biopandas.mol2 import PandasMol2 pmol = PandasMol2().read_mol2('./data/1b5e_1.mol2') [File link: 1b5e_1.mol2 ] %matplotlib inline import matplotlib.pyplot as plt from matplotlib import style style.use('ggplot') For instance, let's say we are interested in the counts of the different atom types that can be found in the MOL2 file; we could do the following: pmol.df['atom_type'].value_counts().plot(kind='bar') plt.xlabel('atom type') plt.ylabel('count') plt.show() If this is too fine-grained for our needs, we could summarize the different atom types by atomic elements: pmol.df['element_type'] = pmol.df['atom_type'].apply(lambda x: x.split('.')[0]) pmol.df['element_type'].value_counts().plot(kind='bar') plt.xlabel('element type') plt.ylabel('count') plt.show() One of the coolest features in pandas is the groupby method. Below is an example plotting the average charge of the different atom types with the standard deviation as error bars: groupby_charge = pmol.df.groupby(['atom_type'])['charge'] groupby_charge.mean().plot(kind='bar', yerr=groupby_charge.std()) plt.ylabel('charge') plt.show()","title":"Plotting"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/#computing-the-root-mean-square-deviation","text":"The Root-mean-square deviation (RMSD) is simply a measure of the average distance between atoms of 2 structures. This calculation of the Cartesian error follows the equation: RMSD(a, b) = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} \\big((a_{ix})^2 + (a_{iy})^2 + (a_{iz})^2 \\big)} \\\\ = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} || a_i + b_i||_2^2} So, assuming that the we have the following 2 conformations of a ligand molecule we can compute the RMSD as follows: from biopandas.mol2 import PandasMol2 l_1 = PandasMol2().read_mol2('./data/1b5e_1.mol2') l_2 = PandasMol2().read_mol2('./data/1b5e_2.mol2') r_heavy = PandasMol2.rmsd(l_1.df, l_2.df) r_all = PandasMol2.rmsd(l_1.df, l_2.df, heavy_only=False) print('Heavy-atom RMSD: %.4f Angstrom' % r_heavy) print('All-atom RMSD: %.4f Angstrom' % r_all) Heavy-atom RMSD: 1.1609 Angstrom All-atom RMSD: 1.5523 Angstrom [File links: 1b5e_1.mol2 , 1b5e_2.mol2 ]","title":"Computing the Root Mean Square Deviation"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/#filtering-atoms-by-distance","text":"We can use the distance method to compute the distance between each atom (or a subset of atoms) in our data frame and a three-dimensional reference point. For example, let's assume were are interested in computing the distance between a keto group in the DMC molecule, which we've seen earlier, and other atoms in the same molecule. First, let's get the coordinates of all keto-groups in this molecule: from biopandas.mol2 import PandasMol2 pmol = PandasMol2().read_mol2('./data/1b5e_1.mol2') keto_coord = pmol.df[pmol.df['atom_type'] == 'O.2'][['x', 'y', 'z']] keto_coord .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } x y z 14 15.0888 6.5824 25.0727 15 18.9314 -0.7527 24.1606 In the following example, we use PandasMol2 's distance method. The distance method returns a pandas Series object containing the Euclidean distance between an atom and all other atoms in the structure. In the following example, keto_coord.values[0] refers to the x, y, z coordinates of the first row (i.e., first keto group) in the array above: print('x, y, z coords:', keto_coord.values[0]) distances = pmol.distance(keto_coord.values[0]) x, y, z coords: [15.0888 6.5824 25.0727] For our convenience, we can add these distances to our MOL2 DataFrame: pmol.df['distances'] = distances pmol.df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... subst_id subst_name charge distances 0 1 C1 18.8934 5.5819 ... 1 <0> -0.1356 4.035144 1 2 C2 18.1301 4.7642 ... 1 <0> -0.0410 3.547712 2 3 C3 18.2645 6.8544 ... 1 <0> 0.4856 3.456969 3 4 C4 16.2520 6.2866 ... 1 <0> 0.8410 1.232313 4 5 C5 15.3820 3.0682 ... 1 <0> 0.0000 3.527546 5 rows \u00d7 10 columns Now, say we are interested in the Euclidean distance between the two keto groups in the molecule: pmol.df[pmol.df['atom_type'] == 'O.2'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... subst_id subst_name charge distances 14 15 O3 15.0888 6.5824 ... 1 <0> -0.5700 0.000000 15 16 O4 18.9314 -0.7527 ... 1 <0> -1.0333 8.330738 2 rows \u00d7 10 columns In the example above, the distance between the two keto groups is 8 angstrom. Another common task that we can perform using these atomic distances is to select only the neighboring atoms of the keto group (here: atoms within 3 angstrom). The code is as follows: all_within_3A = pmol.df[pmol.df['distances'] <= 3.0] all_within_3A.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } atom_id atom_name x y ... subst_id subst_name charge distances 7 8 C8 16.0764 4.1199 ... 1 <0> 0.5801 2.814490 9 10 N1 17.0289 7.1510 ... 1 <0> -0.6610 2.269690 10 11 N2 16.8196 5.0644 ... 1 <0> -0.4691 2.307553 14 15 O3 15.0888 6.5824 ... 1 <0> -0.5700 0.000000 26 27 H7 15.3483 4.6961 ... 1 <0> 0.0000 2.446817 5 rows \u00d7 10 columns","title":"Filtering Atoms by Distance"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/#parsing-multi-mol2-files","text":"","title":"Parsing Multi-MOL2 files"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/#basic-multi-mol2-file-parsing","text":"As mentioned earlier, PandasMol2.read_mol2 method only reads in the first molecule if it is given a multi-MOL2 file. However, if we want to create DataFrames from multiple structures in a MOL2 file, we can use the handy split_multimol2 generator. The split_multimol2 generator yields tuples containing the molecule IDs and the MOL2 content as strings in a list -- each line in the MOL2 file is stored as a string in the list. from biopandas.mol2 import split_multimol2 mol2_id, mol2_cont = next(split_multimol2('./data/40_mol2_files.mol2')) print('Molecule ID:\\n', mol2_id) print('First 10 lines:\\n', mol2_cont[:10]) Molecule ID: ZINC38611810 First 10 lines: ['@<TRIPOS>MOLECULE\\n', 'ZINC38611810\\n', ' 65 68 0 0 0\\n', 'SMALL\\n', 'NO_CHARGES\\n', '\\n', '@<TRIPOS>ATOM\\n', ' 1 C1 -1.1786 2.7011 -4.0323 C.3 1 <0> -0.1537\\n', ' 2 C2 -1.2950 1.2442 -3.5798 C.3 1 <0> -0.1156\\n', ' 3 C3 -0.1742 0.4209 -4.2178 C.3 1 <0> -0.1141\\n'] [File link: 40_mol2_files.mol2 ] We can now use this generator to loop over all files in a multi-MOL2 file and create PandasMol2 DataFrames. A typical use case would be the filtering of mol2 files by certain properties: pdmol = PandasMol2() with open('./data/filtered.mol2', 'w') as f: for mol2 in split_multimol2('./data/40_mol2_files.mol2'): pdmol.read_mol2_from_list(mol2_lines=mol2[1], mol2_code=mol2[0]) # do some analysis keep_molecule = False # save molecule if it passes our filter criterion if keep_molecule: # note that the mol2_text contains the original mol2 content f.write(pdmol.mol2_text)","title":"Basic Multi-MOL2 File Parsing"},{"location":"tutorials/Working_with_MOL2_Structures_in_DataFrames/#using-multiprocessing-for-multi-mol2-file-analysis","text":"To improve the computational efficiency and throughput for multi-mol2 analyses, it is recommended to use the mputil package, which evaluates Python generators lazily. The lazy_imap function from mputil is based on Python's standardlib multiprocessing imap function, but it doesn't consume the generator upfront. This lazy evaluation is important, for example, if we are parsing large (possibly Gigabyte- or Terabyte-large) multi-mol2 files for multiprocessing. The following example provides a template for atom-type based molecule queries, but the data_processor function can be extended to do any kind of functional group queries (for example, involving the 'charge' column and/or PandasMol2.distance method). import pandas as pd from mputil import lazy_imap from biopandas.mol2 import PandasMol2 from biopandas.mol2 import split_multimol2 --------------------------------------------------------------------------- ModuleNotFoundError Traceback (most recent call last) <ipython-input-23-1a655249f2ec> in <module>() 1 import pandas as pd ----> 2 from mputil import lazy_imap 3 from biopandas.mol2 import PandasMol2 4 from biopandas.mol2 import split_multimol2 ModuleNotFoundError: No module named 'mputil' # Selection strings to capture # all molecules that contain at least one sp2 hybridized # oxygen atom and at least one Fluorine atom SELECTIONS = [\"(pdmol.df.atom_type == 'O.2')\", \"(pdmol.df.atom_type == 'F')\"] # Path to the multi-mol2 input file MOL2_FILE = \"./data/40_mol2_files.mol2\" # Data processing function to be run in parallel def data_processor(mol2): \"\"\"Return molecule ID if there's a match and '' otherwise\"\"\" pdmol = PandasMol2().read_mol2_from_list(mol2_lines=mol2[1], mol2_code=mol2[0]) match = mol2[0] for sub_sele in SELECTIONS: if not pd.eval(sub_sele).any(): match = '' break return match # Process molecules and save IDs of hits to disk with open('./data/selected_ids.txt', 'w') as f: searched, found = 0, 0 for chunk in lazy_imap(data_processor=data_processor, data_generator=split_multimol2(MOL2_FILE), n_cpus=0): # means all available cpus for mol2_id in chunk: if mol2_id: # write IDs of matching molecules to disk f.write('%s\\n' % mol2_id) found += 1 searched += len(chunk) print('Searched %d molecules. Got %d hits.' % (searched, found)) [Input File link: 40_mol2_files.mol2 ] [Output File link: selected_ids.txt ]","title":"Using Multiprocessing for Multi-MOL2 File Analysis"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/","text":"Working with PDB Structures in DataFrames Loading PDB Files There are 2 1/2 ways to load a PDB structure into a PandasPdb object. 1 PDB files can be directly fetched from The Protein Data Bank at http://www.rcsb.org via its unique 4-letter after initializing a new PandasPdb object and calling the fetch_pdb method: from biopandas.pdb import PandasPdb # Initialize a new PandasPdb object # and fetch the PDB file from rcsb.org ppdb = PandasPdb().fetch_pdb('3eiy') 2 a) Alternatively, we can load PDB files from local directories as regular PDB files using read_pdb : ppdb.read_pdb('./data/3eiy.pdb') <biopandas.pdb.pandas_pdb.PandasPdb at 0x11912b710> [File link: 3eiy.pdb ] 2 b) Or, we can load them from gzip archives like so (note that the file must end with a '.gz' suffix in order to be recognized as a gzip file): ppdb.read_pdb('./data/3eiy.pdb.gz') <biopandas.pdb.pandas_pdb.PandasPdb at 0x11912b710> [File link: 3eiy.pdb.gz ] After the file was succesfully loaded, we have access to the following attributes: print('PDB Code: %s' % ppdb.code) print('PDB Header Line: %s' % ppdb.header) print('\\nRaw PDB file contents:\\n\\n%s\\n...' % ppdb.pdb_text[:1000]) PDB Code: 3eiy PDB Header Line: HYDROLASE 17-SEP-08 3EIY Raw PDB file contents: HEADER HYDROLASE 17-SEP-08 3EIY TITLE CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHATASE FROM BURKHOLDERIA TITLE 2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE COMPND MOL_ID: 1; COMPND 2 MOLECULE: INORGANIC PYROPHOSPHATASE; COMPND 3 CHAIN: A; COMPND 4 EC: 3.6.1.1; COMPND 5 ENGINEERED: YES SOURCE MOL_ID: 1; SOURCE 2 ORGANISM_SCIENTIFIC: BURKHOLDERIA PSEUDOMALLEI 1710B; SOURCE 3 ORGANISM_TAXID: 320372; SOURCE 4 GENE: PPA, BURPS1710B_1237; SOURCE 5 EXPRESSION_SYSTEM ... The most interesting / useful attribute is the PandasPdb.df DataFrame dictionary though, which gives us access to the PDB files as pandas DataFrames. Let's print the first 3 lines from the ATOM coordinate section to see how it looks like: ppdb.df['ATOM'].head(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 rows \u00d7 21 columns But more on that in the next section. Looking at PDBs in DataFrames PDB files are parsed according to the PDB file format description . More specifically, BioPandas reads the columns of the ATOM and HETATM sections as shown in the following excerpt from http://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM . COLUMNS DATA TYPE CONTENTS biopandas column name 1 - 6 Record name \"ATOM\" record_name 7 - 11 Integer Atom serial number. atom_number 12 blank_1 13 - 16 Atom Atom name. atom_name 17 Character Alternate location indicator. alt_loc 18 - 20 Residue name Residue name. residue_name 21 blank_2 22 Character Chain identifier. chain_id 23 - 26 Integer Residue sequence number. residue_number 27 AChar Code for insertion of residues. insertion 28 - 30 blank_3 31 - 38 Real(8.3) Orthogonal coordinates for X in Angstroms. x_coord 39 - 46 Real(8.3) Orthogonal coordinates for Y in Angstroms. y_coord 47 - 54 Real(8.3) Orthogonal coordinates for Z in Angstroms. z_coord 55 - 60 Real(6.2) Occupancy. occupancy 61 - 66 Real(6.2) Temperature factor (Default = 0.0). bfactor 67-72 blank_4 73 - 76 LString(4) Segment identifier, left-justified. segment_id 77 - 78 LString(2) Element symbol, right-justified. element_symbol 79 - 80 LString(2) Charge on the atom. charge Below is an example of how this would look like in an actual PDB file: Example: 1 2 3 4 5 6 7 8 12345678901234567890123456789012345678901234567890123456789012345678901234567890 ATOM 145 N VAL A 25 32.433 16.336 57.540 1.00 11.92 A1 N ATOM 146 CA VAL A 25 31.132 16.439 58.160 1.00 11.85 A1 C ATOM 147 C VAL A 25 30.447 15.105 58.363 1.00 12.34 A1 C ATOM 148 O VAL A 25 29.520 15.059 59.174 1.00 15.65 A1 O ATOM 149 CB AVAL A 25 30.385 17.437 57.230 0.28 13.88 A1 C ATOM 150 CB BVAL A 25 30.166 17.399 57.373 0.72 15.41 A1 C ATOM 151 CG1AVAL A 25 28.870 17.401 57.336 0.28 12.64 A1 C ATOM 152 CG1BVAL A 25 30.805 18.788 57.449 0.72 15.11 A1 C ATOM 153 CG2AVAL A 25 30.835 18.826 57.661 0.28 13.58 A1 C ATOM 154 CG2BVAL A 25 29.909 16.996 55.922 0.72 13.25 A1 C After loading a PDB file from rcsb.org or our local drive, the PandasPdb.df attribute should contain the following 4 DataFrame objects: from biopandas.pdb import PandasPdb ppdb = PandasPdb() ppdb.read_pdb('./data/3eiy.pdb') ppdb.df.keys() dict_keys(['ATOM', 'HETATM', 'ANISOU', 'OTHERS']) [File link: 3eiy.pdb ] 'ATOM': contains the entries from the ATOM coordinate section 'ATOM': ... entries from the \"HETATM\" coordinate section 'ANISOU': ... entries from the \"ANISOU\" coordinate section 'OTHERS': Everything else that is not a 'ATOM', 'HETATM', or 'ANISOU' entry The columns of the 'HETATM' DataFrame are indentical to the 'ATOM' DataFrame that we've seen earlier: ppdb.df['HETATM'].head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 HETATM 1332 K ... K NaN 1940 1 HETATM 1333 NA ... NA NaN 1941 2 rows \u00d7 21 columns Note that \"ANISOU\" entries are handled a bit differently as specified at http://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM . ppdb.df['ANISOU'].head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... blank_4 element_symbol charge line_idx 0 rows \u00d7 21 columns Not every PDB file contains ANISOU entries (similarly, some PDB files may only contain HETATM or ATOM entries). If records are basent, the DataFrame will be empty as show above. ppdb.df['ANISOU'].empty True Since the DataFrames are fairly wide, let's us take a look at the columns by accessing the DataFrame's column attribute: ppdb.df['ANISOU'].columns Index(['record_name', 'atom_number', 'blank_1', 'atom_name', 'alt_loc', 'residue_name', 'blank_2', 'chain_id', 'residue_number', 'insertion', 'blank_3', 'U(1,1)', 'U(2,2)', 'U(3,3)', 'U(1,2)', 'U(1,3)', 'U(2,3)', 'blank_4', 'element_symbol', 'charge', 'line_idx'], dtype='object') ANISOU records are very similar to ATOM/HETATM records. In fact, the columns 7 - 27 and 73 - 80 are identical to their corresponding ATOM/HETATM records, which means that the 'ANISOU' DataFrame doesn't have the following entries: set(ppdb.df['ATOM'].columns).difference(set(ppdb.df['ANISOU'].columns)) {'b_factor', 'occupancy', 'segment_id', 'x_coord', 'y_coord', 'z_coord'} Instead, the \"ANISOU\" DataFrame contains the anisotropic temperature factors \"U(-,-)\" -- note that these are scaled by a factor of 10^4 ( \\text{Angstroms}^2 ) by convention. set(ppdb.df['ANISOU'].columns).difference(set(ppdb.df['ATOM'].columns)) {'U(1,1)', 'U(1,2)', 'U(1,3)', 'U(2,2)', 'U(2,3)', 'U(3,3)'} Ah, another interesting thing to mention is that the columns already come with the types you'd expect (where object essentially \"means\" str here): ppdb.df['ATOM'].dtypes record_name object atom_number int64 blank_1 object atom_name object alt_loc object residue_name object blank_2 object chain_id object residue_number int64 insertion object blank_3 object x_coord float64 y_coord float64 z_coord float64 occupancy float64 b_factor float64 blank_4 object segment_id object element_symbol object charge float64 line_idx int64 dtype: object Typically, all good things come in threes, however, there is a 4th DataFrame, an'OTHER' DataFrame, which contains everything that wasn't parsed as 'ATOM', 'HETATM', or 'ANISOU' coordinate section: ppdb.df['OTHERS'].head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name entry line_idx 0 HEADER HYDROLASE 17... 0 1 TITLE CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHA... 1 2 TITLE 2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE 2 3 COMPND MOL_ID: 1; 3 4 COMPND 2 MOLECULE: INORGANIC PYROPHOSPHATASE; 4 Although these 'OTHER' entries are typically less useful for structure-related computations, you may still want to take a look at them to get a short summary of the PDB structure and learn about it's potential quirks and gotchas (typically listed in the REMARKs section). Lastly, the \"OTHERS\" DataFrame comes in handy if we want to reconstruct the structure as PDB file as we will see later (note the line_idx columns in all of the DataFrames). Working with PDB DataFrames In the previous sections, we've seen how to load PDB structures into DataFrames, and how to access them. Now, let's talk about manipulating PDB files in DataFrames. from biopandas.pdb import PandasPdb ppdb = PandasPdb() ppdb.read_pdb('./data/3eiy.pdb.gz') ppdb.df['ATOM'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 ATOM 4 O ... O NaN 612 4 ATOM 5 CB ... C NaN 613 5 rows \u00d7 21 columns [File link: 3eiy.pdb.gz ] Okay, there's actually not that much to say ... Once we have our PDB file in the DataFrame format, we have the whole convenience of pandas right there at our fingertips. For example, let's get all Proline residues: ppdb.df['ATOM'][ppdb.df['ATOM']['residue_name'] == 'PRO'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 38 ATOM 39 N ... N NaN 647 39 ATOM 40 CA ... C NaN 648 40 ATOM 41 C ... C NaN 649 41 ATOM 42 O ... O NaN 650 42 ATOM 43 CB ... C NaN 651 5 rows \u00d7 21 columns Or main chain atoms: ppdb.df['ATOM'][ppdb.df['ATOM']['atom_name'] == 'C'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 2 ATOM 3 C ... C NaN 611 8 ATOM 9 C ... C NaN 617 19 ATOM 20 C ... C NaN 628 25 ATOM 26 C ... C NaN 634 33 ATOM 34 C ... C NaN 642 5 rows \u00d7 21 columns It's also easy to strip our coordinate section from hydrogen atoms if there are any ... ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 ATOM 4 O ... O NaN 612 4 ATOM 5 CB ... C NaN 613 5 rows \u00d7 21 columns Or, let's compute the average temperature factor of our protein main chain: mainchain = ppdb.df['ATOM'][(ppdb.df['ATOM']['atom_name'] == 'C') | (ppdb.df['ATOM']['atom_name'] == 'O') | (ppdb.df['ATOM']['atom_name'] == 'N') | (ppdb.df['ATOM']['atom_name'] == 'CA')] bfact_mc_avg = mainchain['b_factor'].mean() print('Average B-Factor [Main Chain]: %.2f' % bfact_mc_avg) Average B-Factor [Main Chain]: 28.83 Plotting Since we are using pandas under the hood, which in turns uses matplotlib under the hood, we can produce quick summary plots of our PDB structures relatively conveniently: from biopandas.pdb import PandasPdb ppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz') [File link: 3eiy.pdb.gz ] %matplotlib inline import matplotlib.pyplot as plt from matplotlib import style style.use('ggplot') ppdb.df['ATOM']['b_factor'].plot(kind='hist') plt.title('Distribution of B-Factors') plt.xlabel('B-factor') plt.ylabel('count') plt.show() ppdb.df['ATOM']['b_factor'].plot(kind='line') plt.title('B-Factors Along the Amino Acid Chain') plt.xlabel('Residue Number') plt.ylabel('B-factor in $A^2$') plt.show() ppdb.df['ATOM']['element_symbol'].value_counts().plot(kind='bar') plt.title('Distribution of Atom Types') plt.xlabel('elements') plt.ylabel('count') plt.show() Computing the Root Mean Square Deviation BioPandas also comes with certain convenience functions, for example, ... The Root-mean-square deviation (RMSD) is simply a measure of the average distance between atoms of 2 protein or ligand structures. This calculation of the Cartesian error follows the equation: RMSD(a, b) = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} \\big((a_{ix})^2 + (a_{iy})^2 + (a_{iz})^2 \\big)} \\\\ = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} || a_i + b_i||_2^2} So, assuming that the we have the following 2 conformations of a ligand molecule we can compute the RMSD as follows: from biopandas.pdb import PandasPdb l_1 = PandasPdb().read_pdb('./data/lig_conf_1.pdb') l_2 = PandasPdb().read_pdb('./data/lig_conf_2.pdb') r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s=None) # all atoms, including hydrogens print('RMSD: %.4f Angstrom' % r) RMSD: 2.6444 Angstrom [File links: lig_conf_1.pdb , lig_conf_2.pdb ] r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s='carbon') # carbon atoms only print('RMSD: %.4f Angstrom' % r) RMSD: 3.1405 Angstrom r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s='heavy') # heavy atoms only print('RMSD: %.4f Angstrom' % r) RMSD: 1.9959 Angstrom Similarly, we can compute the RMSD between 2 related protein structures: The hydrogen-free RMSD: p_1 = PandasPdb().read_pdb('./data/1t48_995.pdb') p_2 = PandasPdb().read_pdb('./data/1t49_995.pdb') r = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='heavy') print('RMSD: %.4f Angstrom' % r) RMSD: 0.7377 Angstrom Or the RMSD between the main chains only: p_1 = PandasPdb().read_pdb('./data/1t48_995.pdb') p_2 = PandasPdb().read_pdb('./data/1t49_995.pdb') r = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='main chain') print('RMSD: %.4f Angstrom' % r) RMSD: 0.4781 Angstrom Filtering PDBs by Distance We can use the distance method to compute the distance between each atom (or a subset of atoms) in our data frame and a three-dimensional reference point. For example: p_1 = PandasPdb().read_pdb('./data/3eiy.pdb') reference_point = (9.362, 41.410, 10.542) distances = p_1.distance(xyz=reference_point, records=('ATOM',)) [File link: 3eiy.pdb ] The distance method returns a Pandas Series object: distances.head() 0 19.267419 1 18.306060 2 16.976934 3 16.902897 4 18.124171 dtype: float64 And we can use this Series object, for instance, to select certain atoms in our DataFrame that fall within a desired distance threshold. For example, let's select all atoms that are within 7A of our reference point: all_within_7A = p_1.df['ATOM'][distances < 7.0] all_within_7A.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 786 ATOM 787 CB ... C NaN 1395 787 ATOM 788 CG ... C NaN 1396 788 ATOM 789 CD1 ... C NaN 1397 789 ATOM 790 CD2 ... C NaN 1398 790 ATOM 791 N ... N NaN 1399 5 rows \u00d7 21 columns Visualized in PyMOL, this subset (yellow surface) would look as follows: Converting Amino Acid codes from 3- to 1-letter codes Residues in the residue_name field can be converted into 1-letter amino acid codes, which may be useful for further sequence analysis, for example, pair-wise or multiple sequence alignments: from biopandas.pdb import PandasPdb ppdb = PandasPdb().fetch_pdb('5mtn') sequence = ppdb.amino3to1() sequence.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } chain_id residue_name 1378 B I 1386 B N 1394 B Y 1406 B R 1417 B T As shown above, the amino3to1 method returns a DataFrame containing the chain_id and residue_name of the translated 1-letter amino acids. If you like to work with the sequence as a Python list of string characters, you could do the following: sequence_list = list(sequence.loc[sequence['chain_id'] == 'A', 'residue_name']) sequence_list[-5:] # last 5 residues of chain A ['V', 'R', 'H', 'Y', 'T'] And if you prefer to work with the sequence as a string, you can use the join method: ''.join(sequence.loc[sequence['chain_id'] == 'A', 'residue_name']) 'SLEPEPWFFKNLSRKDAERQLLAPGNTHGSFLIRESESTAGSFSLSVRDFDQGEVVKHYKIRNLDNGGFYISPRITFPGLHELVRHYT' To iterate over the sequences of multi-chain proteins, you can use the unique method as shown below: for chain_id in sequence['chain_id'].unique(): print('\\nChain ID: %s' % chain_id) print(''.join(sequence.loc[sequence['chain_id'] == chain_id, 'residue_name'])) Chain ID: A SLEPEPWFFKNLSRKDAERQLLAPGNTHGSFLIRESESTAGSFSLSVRDFDQGEVVKHYKIRNLDNGGFYISPRITFPGLHELVRHYT Chain ID: B SVSSVPTKLEVVAATPTSLLISWDAPAVTVVYYLITYGETGSPWPGGQAFEVPGSKSTATISGLKPGVDYTITVYAHRSSYGYSENPISINYRT Wrapping it up - Saving PDB structures Finally, let's talk about how to get the PDB structures out of the DataFrame format back into the beloved .pdb format. Let's say we loaded a PDB structure, removed it from it's hydrogens: from biopandas.pdb import PandasPdb ppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz') ppdb.df['ATOM'] = ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H'] [File link: 3eiy.pdb.gz ] We can save the file using the PandasPdb.to_pdb method: ppdb.to_pdb(path='./data/3eiy_stripped.pdb', records=None, gz=False, append_newline=True) [File link: 3eiy_stripped.pdb ] By default, all records (that is, 'ATOM', 'HETATM', 'OTHERS', 'ANISOU') are written if we set records=None . Alternatively, let's say we want to get rid of the 'ANISOU' entries and produce a compressed gzip archive of our PDB structure: ppdb.to_pdb(path='./data/3eiy_stripped.pdb.gz', records=['ATOM', 'HETATM', 'OTHERS'], gz=True, append_newline=True) [File link: 3eiy_stripped.pdb.gz ]","title":"Working with PDB Structures in DataFrames"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#working-with-pdb-structures-in-dataframes","text":"","title":"Working with PDB Structures in DataFrames"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#loading-pdb-files","text":"There are 2 1/2 ways to load a PDB structure into a PandasPdb object.","title":"Loading PDB Files"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#1","text":"PDB files can be directly fetched from The Protein Data Bank at http://www.rcsb.org via its unique 4-letter after initializing a new PandasPdb object and calling the fetch_pdb method: from biopandas.pdb import PandasPdb # Initialize a new PandasPdb object # and fetch the PDB file from rcsb.org ppdb = PandasPdb().fetch_pdb('3eiy')","title":"1"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#2-a","text":"Alternatively, we can load PDB files from local directories as regular PDB files using read_pdb : ppdb.read_pdb('./data/3eiy.pdb') <biopandas.pdb.pandas_pdb.PandasPdb at 0x11912b710> [File link: 3eiy.pdb ]","title":"2 a)"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#2-b","text":"Or, we can load them from gzip archives like so (note that the file must end with a '.gz' suffix in order to be recognized as a gzip file): ppdb.read_pdb('./data/3eiy.pdb.gz') <biopandas.pdb.pandas_pdb.PandasPdb at 0x11912b710> [File link: 3eiy.pdb.gz ] After the file was succesfully loaded, we have access to the following attributes: print('PDB Code: %s' % ppdb.code) print('PDB Header Line: %s' % ppdb.header) print('\\nRaw PDB file contents:\\n\\n%s\\n...' % ppdb.pdb_text[:1000]) PDB Code: 3eiy PDB Header Line: HYDROLASE 17-SEP-08 3EIY Raw PDB file contents: HEADER HYDROLASE 17-SEP-08 3EIY TITLE CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHATASE FROM BURKHOLDERIA TITLE 2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE COMPND MOL_ID: 1; COMPND 2 MOLECULE: INORGANIC PYROPHOSPHATASE; COMPND 3 CHAIN: A; COMPND 4 EC: 3.6.1.1; COMPND 5 ENGINEERED: YES SOURCE MOL_ID: 1; SOURCE 2 ORGANISM_SCIENTIFIC: BURKHOLDERIA PSEUDOMALLEI 1710B; SOURCE 3 ORGANISM_TAXID: 320372; SOURCE 4 GENE: PPA, BURPS1710B_1237; SOURCE 5 EXPRESSION_SYSTEM ... The most interesting / useful attribute is the PandasPdb.df DataFrame dictionary though, which gives us access to the PDB files as pandas DataFrames. Let's print the first 3 lines from the ATOM coordinate section to see how it looks like: ppdb.df['ATOM'].head(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 rows \u00d7 21 columns But more on that in the next section.","title":"2 b)"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#looking-at-pdbs-in-dataframes","text":"PDB files are parsed according to the PDB file format description . More specifically, BioPandas reads the columns of the ATOM and HETATM sections as shown in the following excerpt from http://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM . COLUMNS DATA TYPE CONTENTS biopandas column name 1 - 6 Record name \"ATOM\" record_name 7 - 11 Integer Atom serial number. atom_number 12 blank_1 13 - 16 Atom Atom name. atom_name 17 Character Alternate location indicator. alt_loc 18 - 20 Residue name Residue name. residue_name 21 blank_2 22 Character Chain identifier. chain_id 23 - 26 Integer Residue sequence number. residue_number 27 AChar Code for insertion of residues. insertion 28 - 30 blank_3 31 - 38 Real(8.3) Orthogonal coordinates for X in Angstroms. x_coord 39 - 46 Real(8.3) Orthogonal coordinates for Y in Angstroms. y_coord 47 - 54 Real(8.3) Orthogonal coordinates for Z in Angstroms. z_coord 55 - 60 Real(6.2) Occupancy. occupancy 61 - 66 Real(6.2) Temperature factor (Default = 0.0). bfactor 67-72 blank_4 73 - 76 LString(4) Segment identifier, left-justified. segment_id 77 - 78 LString(2) Element symbol, right-justified. element_symbol 79 - 80 LString(2) Charge on the atom. charge Below is an example of how this would look like in an actual PDB file: Example: 1 2 3 4 5 6 7 8 12345678901234567890123456789012345678901234567890123456789012345678901234567890 ATOM 145 N VAL A 25 32.433 16.336 57.540 1.00 11.92 A1 N ATOM 146 CA VAL A 25 31.132 16.439 58.160 1.00 11.85 A1 C ATOM 147 C VAL A 25 30.447 15.105 58.363 1.00 12.34 A1 C ATOM 148 O VAL A 25 29.520 15.059 59.174 1.00 15.65 A1 O ATOM 149 CB AVAL A 25 30.385 17.437 57.230 0.28 13.88 A1 C ATOM 150 CB BVAL A 25 30.166 17.399 57.373 0.72 15.41 A1 C ATOM 151 CG1AVAL A 25 28.870 17.401 57.336 0.28 12.64 A1 C ATOM 152 CG1BVAL A 25 30.805 18.788 57.449 0.72 15.11 A1 C ATOM 153 CG2AVAL A 25 30.835 18.826 57.661 0.28 13.58 A1 C ATOM 154 CG2BVAL A 25 29.909 16.996 55.922 0.72 13.25 A1 C After loading a PDB file from rcsb.org or our local drive, the PandasPdb.df attribute should contain the following 4 DataFrame objects: from biopandas.pdb import PandasPdb ppdb = PandasPdb() ppdb.read_pdb('./data/3eiy.pdb') ppdb.df.keys() dict_keys(['ATOM', 'HETATM', 'ANISOU', 'OTHERS']) [File link: 3eiy.pdb ] 'ATOM': contains the entries from the ATOM coordinate section 'ATOM': ... entries from the \"HETATM\" coordinate section 'ANISOU': ... entries from the \"ANISOU\" coordinate section 'OTHERS': Everything else that is not a 'ATOM', 'HETATM', or 'ANISOU' entry The columns of the 'HETATM' DataFrame are indentical to the 'ATOM' DataFrame that we've seen earlier: ppdb.df['HETATM'].head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 HETATM 1332 K ... K NaN 1940 1 HETATM 1333 NA ... NA NaN 1941 2 rows \u00d7 21 columns Note that \"ANISOU\" entries are handled a bit differently as specified at http://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM . ppdb.df['ANISOU'].head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... blank_4 element_symbol charge line_idx 0 rows \u00d7 21 columns Not every PDB file contains ANISOU entries (similarly, some PDB files may only contain HETATM or ATOM entries). If records are basent, the DataFrame will be empty as show above. ppdb.df['ANISOU'].empty True Since the DataFrames are fairly wide, let's us take a look at the columns by accessing the DataFrame's column attribute: ppdb.df['ANISOU'].columns Index(['record_name', 'atom_number', 'blank_1', 'atom_name', 'alt_loc', 'residue_name', 'blank_2', 'chain_id', 'residue_number', 'insertion', 'blank_3', 'U(1,1)', 'U(2,2)', 'U(3,3)', 'U(1,2)', 'U(1,3)', 'U(2,3)', 'blank_4', 'element_symbol', 'charge', 'line_idx'], dtype='object') ANISOU records are very similar to ATOM/HETATM records. In fact, the columns 7 - 27 and 73 - 80 are identical to their corresponding ATOM/HETATM records, which means that the 'ANISOU' DataFrame doesn't have the following entries: set(ppdb.df['ATOM'].columns).difference(set(ppdb.df['ANISOU'].columns)) {'b_factor', 'occupancy', 'segment_id', 'x_coord', 'y_coord', 'z_coord'} Instead, the \"ANISOU\" DataFrame contains the anisotropic temperature factors \"U(-,-)\" -- note that these are scaled by a factor of 10^4 ( \\text{Angstroms}^2 ) by convention. set(ppdb.df['ANISOU'].columns).difference(set(ppdb.df['ATOM'].columns)) {'U(1,1)', 'U(1,2)', 'U(1,3)', 'U(2,2)', 'U(2,3)', 'U(3,3)'} Ah, another interesting thing to mention is that the columns already come with the types you'd expect (where object essentially \"means\" str here): ppdb.df['ATOM'].dtypes record_name object atom_number int64 blank_1 object atom_name object alt_loc object residue_name object blank_2 object chain_id object residue_number int64 insertion object blank_3 object x_coord float64 y_coord float64 z_coord float64 occupancy float64 b_factor float64 blank_4 object segment_id object element_symbol object charge float64 line_idx int64 dtype: object Typically, all good things come in threes, however, there is a 4th DataFrame, an'OTHER' DataFrame, which contains everything that wasn't parsed as 'ATOM', 'HETATM', or 'ANISOU' coordinate section: ppdb.df['OTHERS'].head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name entry line_idx 0 HEADER HYDROLASE 17... 0 1 TITLE CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHA... 1 2 TITLE 2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE 2 3 COMPND MOL_ID: 1; 3 4 COMPND 2 MOLECULE: INORGANIC PYROPHOSPHATASE; 4 Although these 'OTHER' entries are typically less useful for structure-related computations, you may still want to take a look at them to get a short summary of the PDB structure and learn about it's potential quirks and gotchas (typically listed in the REMARKs section). Lastly, the \"OTHERS\" DataFrame comes in handy if we want to reconstruct the structure as PDB file as we will see later (note the line_idx columns in all of the DataFrames).","title":"Looking at PDBs in DataFrames"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#working-with-pdb-dataframes","text":"In the previous sections, we've seen how to load PDB structures into DataFrames, and how to access them. Now, let's talk about manipulating PDB files in DataFrames. from biopandas.pdb import PandasPdb ppdb = PandasPdb() ppdb.read_pdb('./data/3eiy.pdb.gz') ppdb.df['ATOM'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 ATOM 4 O ... O NaN 612 4 ATOM 5 CB ... C NaN 613 5 rows \u00d7 21 columns [File link: 3eiy.pdb.gz ] Okay, there's actually not that much to say ... Once we have our PDB file in the DataFrame format, we have the whole convenience of pandas right there at our fingertips. For example, let's get all Proline residues: ppdb.df['ATOM'][ppdb.df['ATOM']['residue_name'] == 'PRO'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 38 ATOM 39 N ... N NaN 647 39 ATOM 40 CA ... C NaN 648 40 ATOM 41 C ... C NaN 649 41 ATOM 42 O ... O NaN 650 42 ATOM 43 CB ... C NaN 651 5 rows \u00d7 21 columns Or main chain atoms: ppdb.df['ATOM'][ppdb.df['ATOM']['atom_name'] == 'C'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 2 ATOM 3 C ... C NaN 611 8 ATOM 9 C ... C NaN 617 19 ATOM 20 C ... C NaN 628 25 ATOM 26 C ... C NaN 634 33 ATOM 34 C ... C NaN 642 5 rows \u00d7 21 columns It's also easy to strip our coordinate section from hydrogen atoms if there are any ... ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 ATOM 4 O ... O NaN 612 4 ATOM 5 CB ... C NaN 613 5 rows \u00d7 21 columns Or, let's compute the average temperature factor of our protein main chain: mainchain = ppdb.df['ATOM'][(ppdb.df['ATOM']['atom_name'] == 'C') | (ppdb.df['ATOM']['atom_name'] == 'O') | (ppdb.df['ATOM']['atom_name'] == 'N') | (ppdb.df['ATOM']['atom_name'] == 'CA')] bfact_mc_avg = mainchain['b_factor'].mean() print('Average B-Factor [Main Chain]: %.2f' % bfact_mc_avg) Average B-Factor [Main Chain]: 28.83","title":"Working with PDB DataFrames"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#plotting","text":"Since we are using pandas under the hood, which in turns uses matplotlib under the hood, we can produce quick summary plots of our PDB structures relatively conveniently: from biopandas.pdb import PandasPdb ppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz') [File link: 3eiy.pdb.gz ] %matplotlib inline import matplotlib.pyplot as plt from matplotlib import style style.use('ggplot') ppdb.df['ATOM']['b_factor'].plot(kind='hist') plt.title('Distribution of B-Factors') plt.xlabel('B-factor') plt.ylabel('count') plt.show() ppdb.df['ATOM']['b_factor'].plot(kind='line') plt.title('B-Factors Along the Amino Acid Chain') plt.xlabel('Residue Number') plt.ylabel('B-factor in $A^2$') plt.show() ppdb.df['ATOM']['element_symbol'].value_counts().plot(kind='bar') plt.title('Distribution of Atom Types') plt.xlabel('elements') plt.ylabel('count') plt.show()","title":"Plotting"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#computing-the-root-mean-square-deviation","text":"BioPandas also comes with certain convenience functions, for example, ... The Root-mean-square deviation (RMSD) is simply a measure of the average distance between atoms of 2 protein or ligand structures. This calculation of the Cartesian error follows the equation: RMSD(a, b) = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} \\big((a_{ix})^2 + (a_{iy})^2 + (a_{iz})^2 \\big)} \\\\ = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} || a_i + b_i||_2^2} So, assuming that the we have the following 2 conformations of a ligand molecule we can compute the RMSD as follows: from biopandas.pdb import PandasPdb l_1 = PandasPdb().read_pdb('./data/lig_conf_1.pdb') l_2 = PandasPdb().read_pdb('./data/lig_conf_2.pdb') r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s=None) # all atoms, including hydrogens print('RMSD: %.4f Angstrom' % r) RMSD: 2.6444 Angstrom [File links: lig_conf_1.pdb , lig_conf_2.pdb ] r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s='carbon') # carbon atoms only print('RMSD: %.4f Angstrom' % r) RMSD: 3.1405 Angstrom r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s='heavy') # heavy atoms only print('RMSD: %.4f Angstrom' % r) RMSD: 1.9959 Angstrom Similarly, we can compute the RMSD between 2 related protein structures: The hydrogen-free RMSD: p_1 = PandasPdb().read_pdb('./data/1t48_995.pdb') p_2 = PandasPdb().read_pdb('./data/1t49_995.pdb') r = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='heavy') print('RMSD: %.4f Angstrom' % r) RMSD: 0.7377 Angstrom Or the RMSD between the main chains only: p_1 = PandasPdb().read_pdb('./data/1t48_995.pdb') p_2 = PandasPdb().read_pdb('./data/1t49_995.pdb') r = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='main chain') print('RMSD: %.4f Angstrom' % r) RMSD: 0.4781 Angstrom","title":"Computing the Root Mean Square Deviation"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#filtering-pdbs-by-distance","text":"We can use the distance method to compute the distance between each atom (or a subset of atoms) in our data frame and a three-dimensional reference point. For example: p_1 = PandasPdb().read_pdb('./data/3eiy.pdb') reference_point = (9.362, 41.410, 10.542) distances = p_1.distance(xyz=reference_point, records=('ATOM',)) [File link: 3eiy.pdb ] The distance method returns a Pandas Series object: distances.head() 0 19.267419 1 18.306060 2 16.976934 3 16.902897 4 18.124171 dtype: float64 And we can use this Series object, for instance, to select certain atoms in our DataFrame that fall within a desired distance threshold. For example, let's select all atoms that are within 7A of our reference point: all_within_7A = p_1.df['ATOM'][distances < 7.0] all_within_7A.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 786 ATOM 787 CB ... C NaN 1395 787 ATOM 788 CG ... C NaN 1396 788 ATOM 789 CD1 ... C NaN 1397 789 ATOM 790 CD2 ... C NaN 1398 790 ATOM 791 N ... N NaN 1399 5 rows \u00d7 21 columns Visualized in PyMOL, this subset (yellow surface) would look as follows:","title":"Filtering PDBs by Distance"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#converting-amino-acid-codes-from-3-to-1-letter-codes","text":"Residues in the residue_name field can be converted into 1-letter amino acid codes, which may be useful for further sequence analysis, for example, pair-wise or multiple sequence alignments: from biopandas.pdb import PandasPdb ppdb = PandasPdb().fetch_pdb('5mtn') sequence = ppdb.amino3to1() sequence.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } chain_id residue_name 1378 B I 1386 B N 1394 B Y 1406 B R 1417 B T As shown above, the amino3to1 method returns a DataFrame containing the chain_id and residue_name of the translated 1-letter amino acids. If you like to work with the sequence as a Python list of string characters, you could do the following: sequence_list = list(sequence.loc[sequence['chain_id'] == 'A', 'residue_name']) sequence_list[-5:] # last 5 residues of chain A ['V', 'R', 'H', 'Y', 'T'] And if you prefer to work with the sequence as a string, you can use the join method: ''.join(sequence.loc[sequence['chain_id'] == 'A', 'residue_name']) 'SLEPEPWFFKNLSRKDAERQLLAPGNTHGSFLIRESESTAGSFSLSVRDFDQGEVVKHYKIRNLDNGGFYISPRITFPGLHELVRHYT' To iterate over the sequences of multi-chain proteins, you can use the unique method as shown below: for chain_id in sequence['chain_id'].unique(): print('\\nChain ID: %s' % chain_id) print(''.join(sequence.loc[sequence['chain_id'] == chain_id, 'residue_name'])) Chain ID: A SLEPEPWFFKNLSRKDAERQLLAPGNTHGSFLIRESESTAGSFSLSVRDFDQGEVVKHYKIRNLDNGGFYISPRITFPGLHELVRHYT Chain ID: B SVSSVPTKLEVVAATPTSLLISWDAPAVTVVYYLITYGETGSPWPGGQAFEVPGSKSTATISGLKPGVDYTITVYAHRSSYGYSENPISINYRT","title":"Converting Amino Acid codes from 3- to 1-letter codes"},{"location":"tutorials/Working_with_PDB_Structures_in_DataFrames/#wrapping-it-up-saving-pdb-structures","text":"Finally, let's talk about how to get the PDB structures out of the DataFrame format back into the beloved .pdb format. Let's say we loaded a PDB structure, removed it from it's hydrogens: from biopandas.pdb import PandasPdb ppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz') ppdb.df['ATOM'] = ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H'] [File link: 3eiy.pdb.gz ] We can save the file using the PandasPdb.to_pdb method: ppdb.to_pdb(path='./data/3eiy_stripped.pdb', records=None, gz=False, append_newline=True) [File link: 3eiy_stripped.pdb ] By default, all records (that is, 'ATOM', 'HETATM', 'OTHERS', 'ANISOU') are written if we set records=None . Alternatively, let's say we want to get rid of the 'ANISOU' entries and produce a compressed gzip archive of our PDB structure: ppdb.to_pdb(path='./data/3eiy_stripped.pdb.gz', records=['ATOM', 'HETATM', 'OTHERS'], gz=True, append_newline=True) [File link: 3eiy_stripped.pdb.gz ]","title":"Wrapping it up - Saving PDB structures"},{"location":"tutorials/test/","text":"Working with PDB Structures in DataFrames Loading PDB Files There are 2 1/2 ways to load a PDB structure into a PandasPdb object. 1 PDB files can be directly fetched from The Protein Data Bank at http://www.rcsb.org via its unique 4-letter after initializing a new PandasPdb object and calling the fetch_pdb method: from biopandas.pdb import PandasPdb # Initialize a new PandasPdb object # and fetch the PDB file from rcsb.org ppdb = PandasPdb().fetch_pdb('3eiy') 2 a) Alternatively, we can load PDB files from local directories as regular PDB files using read_pdb : ppdb.read_pdb('./data/3eiy.pdb') <biopandas.pdb.pandas_pdb.PandasPdb at 0x11912b710> [File link: 3eiy.pdb ] 2 b) Or, we can load them from gzip archives like so (note that the file must end with a '.gz' suffix in order to be recognized as a gzip file): ppdb.read_pdb('./data/3eiy.pdb.gz') <biopandas.pdb.pandas_pdb.PandasPdb at 0x11912b710> [File link: 3eiy.pdb.gz ] After the file was succesfully loaded, we have access to the following attributes: print('PDB Code: %s' % ppdb.code) print('PDB Header Line: %s' % ppdb.header) print('\\nRaw PDB file contents:\\n\\n%s\\n...' % ppdb.pdb_text[:1000]) PDB Code: 3eiy PDB Header Line: HYDROLASE 17-SEP-08 3EIY Raw PDB file contents: HEADER HYDROLASE 17-SEP-08 3EIY TITLE CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHATASE FROM BURKHOLDERIA TITLE 2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE COMPND MOL_ID: 1; COMPND 2 MOLECULE: INORGANIC PYROPHOSPHATASE; COMPND 3 CHAIN: A; COMPND 4 EC: 3.6.1.1; COMPND 5 ENGINEERED: YES SOURCE MOL_ID: 1; SOURCE 2 ORGANISM_SCIENTIFIC: BURKHOLDERIA PSEUDOMALLEI 1710B; SOURCE 3 ORGANISM_TAXID: 320372; SOURCE 4 GENE: PPA, BURPS1710B_1237; SOURCE 5 EXPRESSION_SYSTEM ... The most interesting / useful attribute is the PandasPdb.df DataFrame dictionary though, which gives us access to the PDB files as pandas DataFrames. Let's print the first 3 lines from the ATOM coordinate section to see how it looks like: ppdb.df['ATOM'].head(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 rows \u00d7 21 columns But more on that in the next section. Looking at PDBs in DataFrames PDB files are parsed according to the PDB file format description . More specifically, BioPandas reads the columns of the ATOM and HETATM sections as shown in the following excerpt from http://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM . COLUMNS DATA TYPE CONTENTS biopandas column name 1 - 6 Record name \"ATOM\" record_name 7 - 11 Integer Atom serial number. atom_number 12 blank_1 13 - 16 Atom Atom name. atom_name 17 Character Alternate location indicator. alt_loc 18 - 20 Residue name Residue name. residue_name 21 blank_2 22 Character Chain identifier. chain_id 23 - 26 Integer Residue sequence number. residue_number 27 AChar Code for insertion of residues. insertion 28 - 30 blank_3 31 - 38 Real(8.3) Orthogonal coordinates for X in Angstroms. x_coord 39 - 46 Real(8.3) Orthogonal coordinates for Y in Angstroms. y_coord 47 - 54 Real(8.3) Orthogonal coordinates for Z in Angstroms. z_coord 55 - 60 Real(6.2) Occupancy. occupancy 61 - 66 Real(6.2) Temperature factor (Default = 0.0). bfactor 67-72 blank_4 73 - 76 LString(4) Segment identifier, left-justified. segment_id 77 - 78 LString(2) Element symbol, right-justified. element_symbol 79 - 80 LString(2) Charge on the atom. charge Below is an example of how this would look like in an actual PDB file: Example: 1 2 3 4 5 6 7 8 12345678901234567890123456789012345678901234567890123456789012345678901234567890 ATOM 145 N VAL A 25 32.433 16.336 57.540 1.00 11.92 A1 N ATOM 146 CA VAL A 25 31.132 16.439 58.160 1.00 11.85 A1 C ATOM 147 C VAL A 25 30.447 15.105 58.363 1.00 12.34 A1 C ATOM 148 O VAL A 25 29.520 15.059 59.174 1.00 15.65 A1 O ATOM 149 CB AVAL A 25 30.385 17.437 57.230 0.28 13.88 A1 C ATOM 150 CB BVAL A 25 30.166 17.399 57.373 0.72 15.41 A1 C ATOM 151 CG1AVAL A 25 28.870 17.401 57.336 0.28 12.64 A1 C ATOM 152 CG1BVAL A 25 30.805 18.788 57.449 0.72 15.11 A1 C ATOM 153 CG2AVAL A 25 30.835 18.826 57.661 0.28 13.58 A1 C ATOM 154 CG2BVAL A 25 29.909 16.996 55.922 0.72 13.25 A1 C After loading a PDB file from rcsb.org or our local drive, the PandasPdb.df attribute should contain the following 4 DataFrame objects: from biopandas.pdb import PandasPdb ppdb = PandasPdb() ppdb.read_pdb('./data/3eiy.pdb') ppdb.df.keys() dict_keys(['ATOM', 'HETATM', 'ANISOU', 'OTHERS']) [File link: 3eiy.pdb ] 'ATOM': contains the entries from the ATOM coordinate section 'ATOM': ... entries from the \"HETATM\" coordinate section 'ANISOU': ... entries from the \"ANISOU\" coordinate section 'OTHERS': Everything else that is not a 'ATOM', 'HETATM', or 'ANISOU' entry The columns of the 'HETATM' DataFrame are indentical to the 'ATOM' DataFrame that we've seen earlier: ppdb.df['HETATM'].head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 HETATM 1332 K ... K NaN 1940 1 HETATM 1333 NA ... NA NaN 1941 2 rows \u00d7 21 columns Note that \"ANISOU\" entries are handled a bit differently as specified at http://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM . ppdb.df['ANISOU'].head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... blank_4 element_symbol charge line_idx 0 rows \u00d7 21 columns Not every PDB file contains ANISOU entries (similarly, some PDB files may only contain HETATM or ATOM entries). If records are basent, the DataFrame will be empty as show above. ppdb.df['ANISOU'].empty True Since the DataFrames are fairly wide, let's us take a look at the columns by accessing the DataFrame's column attribute: ppdb.df['ANISOU'].columns Index(['record_name', 'atom_number', 'blank_1', 'atom_name', 'alt_loc', 'residue_name', 'blank_2', 'chain_id', 'residue_number', 'insertion', 'blank_3', 'U(1,1)', 'U(2,2)', 'U(3,3)', 'U(1,2)', 'U(1,3)', 'U(2,3)', 'blank_4', 'element_symbol', 'charge', 'line_idx'], dtype='object') ANISOU records are very similar to ATOM/HETATM records. In fact, the columns 7 - 27 and 73 - 80 are identical to their corresponding ATOM/HETATM records, which means that the 'ANISOU' DataFrame doesn't have the following entries: set(ppdb.df['ATOM'].columns).difference(set(ppdb.df['ANISOU'].columns)) {'b_factor', 'occupancy', 'segment_id', 'x_coord', 'y_coord', 'z_coord'} Instead, the \"ANISOU\" DataFrame contains the anisotropic temperature factors \"U(-,-)\" -- note that these are scaled by a factor of 10^4 ( \\text{Angstroms}^2 ) by convention. set(ppdb.df['ANISOU'].columns).difference(set(ppdb.df['ATOM'].columns)) {'U(1,1)', 'U(1,2)', 'U(1,3)', 'U(2,2)', 'U(2,3)', 'U(3,3)'} Ah, another interesting thing to mention is that the columns already come with the types you'd expect (where object essentially \"means\" str here): ppdb.df['ATOM'].dtypes record_name object atom_number int64 blank_1 object atom_name object alt_loc object residue_name object blank_2 object chain_id object residue_number int64 insertion object blank_3 object x_coord float64 y_coord float64 z_coord float64 occupancy float64 b_factor float64 blank_4 object segment_id object element_symbol object charge float64 line_idx int64 dtype: object Typically, all good things come in threes, however, there is a 4th DataFrame, an'OTHER' DataFrame, which contains everything that wasn't parsed as 'ATOM', 'HETATM', or 'ANISOU' coordinate section: ppdb.df['OTHERS'].head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name entry line_idx 0 HEADER HYDROLASE 17... 0 1 TITLE CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHA... 1 2 TITLE 2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE 2 3 COMPND MOL_ID: 1; 3 4 COMPND 2 MOLECULE: INORGANIC PYROPHOSPHATASE; 4 Although these 'OTHER' entries are typically less useful for structure-related computations, you may still want to take a look at them to get a short summary of the PDB structure and learn about it's potential quirks and gotchas (typically listed in the REMARKs section). Lastly, the \"OTHERS\" DataFrame comes in handy if we want to reconstruct the structure as PDB file as we will see later (note the line_idx columns in all of the DataFrames). Working with PDB DataFrames In the previous sections, we've seen how to load PDB structures into DataFrames, and how to access them. Now, let's talk about manipulating PDB files in DataFrames. from biopandas.pdb import PandasPdb ppdb = PandasPdb() ppdb.read_pdb('./data/3eiy.pdb.gz') ppdb.df['ATOM'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 ATOM 4 O ... O NaN 612 4 ATOM 5 CB ... C NaN 613 5 rows \u00d7 21 columns [File link: 3eiy.pdb.gz ] Okay, there's actually not that much to say ... Once we have our PDB file in the DataFrame format, we have the whole convenience of pandas right there at our fingertips. For example, let's get all Proline residues: ppdb.df['ATOM'][ppdb.df['ATOM']['residue_name'] == 'PRO'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 38 ATOM 39 N ... N NaN 647 39 ATOM 40 CA ... C NaN 648 40 ATOM 41 C ... C NaN 649 41 ATOM 42 O ... O NaN 650 42 ATOM 43 CB ... C NaN 651 5 rows \u00d7 21 columns Or main chain atoms: ppdb.df['ATOM'][ppdb.df['ATOM']['atom_name'] == 'C'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 2 ATOM 3 C ... C NaN 611 8 ATOM 9 C ... C NaN 617 19 ATOM 20 C ... C NaN 628 25 ATOM 26 C ... C NaN 634 33 ATOM 34 C ... C NaN 642 5 rows \u00d7 21 columns It's also easy to strip our coordinate section from hydrogen atoms if there are any ... ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 ATOM 4 O ... O NaN 612 4 ATOM 5 CB ... C NaN 613 5 rows \u00d7 21 columns Or, let's compute the average temperature factor of our protein main chain: mainchain = ppdb.df['ATOM'][(ppdb.df['ATOM']['atom_name'] == 'C') | (ppdb.df['ATOM']['atom_name'] == 'O') | (ppdb.df['ATOM']['atom_name'] == 'N') | (ppdb.df['ATOM']['atom_name'] == 'CA')] bfact_mc_avg = mainchain['b_factor'].mean() print('Average B-Factor [Main Chain]: %.2f' % bfact_mc_avg) Average B-Factor [Main Chain]: 28.83 Plotting Since we are using pandas under the hood, which in turns uses matplotlib under the hood, we can produce quick summary plots of our PDB structures relatively conveniently: from biopandas.pdb import PandasPdb ppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz') [File link: 3eiy.pdb.gz ] %matplotlib inline import matplotlib.pyplot as plt from matplotlib import style style.use('ggplot') ppdb.df['ATOM']['b_factor'].plot(kind='hist') plt.title('Distribution of B-Factors') plt.xlabel('B-factor') plt.ylabel('count') plt.show() ppdb.df['ATOM']['b_factor'].plot(kind='line') plt.title('B-Factors Along the Amino Acid Chain') plt.xlabel('Residue Number') plt.ylabel('B-factor in $A^2$') plt.show() ppdb.df['ATOM']['element_symbol'].value_counts().plot(kind='bar') plt.title('Distribution of Atom Types') plt.xlabel('elements') plt.ylabel('count') plt.show() Computing the Root Mean Square Deviation BioPandas also comes with certain convenience functions, for example, ... The Root-mean-square deviation (RMSD) is simply a measure of the average distance between atoms of 2 protein or ligand structures. This calculation of the Cartesian error follows the equation: RMSD(a, b) = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} \\big((a_{ix})^2 + (a_{iy})^2 + (a_{iz})^2 \\big)} \\\\ = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} || a_i + b_i||_2^2} So, assuming that the we have the following 2 conformations of a ligand molecule we can compute the RMSD as follows: from biopandas.pdb import PandasPdb l_1 = PandasPdb().read_pdb('./data/lig_conf_1.pdb') l_2 = PandasPdb().read_pdb('./data/lig_conf_2.pdb') r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s=None) # all atoms, including hydrogens print('RMSD: %.4f Angstrom' % r) RMSD: 2.6444 Angstrom [File links: lig_conf_1.pdb , lig_conf_2.pdb ] r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s='carbon') # carbon atoms only print('RMSD: %.4f Angstrom' % r) RMSD: 3.1405 Angstrom r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s='heavy') # heavy atoms only print('RMSD: %.4f Angstrom' % r) RMSD: 1.9959 Angstrom Similarly, we can compute the RMSD between 2 related protein structures: The hydrogen-free RMSD: p_1 = PandasPdb().read_pdb('./data/1t48_995.pdb') p_2 = PandasPdb().read_pdb('./data/1t49_995.pdb') r = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='heavy') print('RMSD: %.4f Angstrom' % r) RMSD: 0.7377 Angstrom Or the RMSD between the main chains only: p_1 = PandasPdb().read_pdb('./data/1t48_995.pdb') p_2 = PandasPdb().read_pdb('./data/1t49_995.pdb') r = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='main chain') print('RMSD: %.4f Angstrom' % r) RMSD: 0.4781 Angstrom Filtering PDBs by Distance We can use the distance method to compute the distance between each atom (or a subset of atoms) in our data frame and a three-dimensional reference point. For example: p_1 = PandasPdb().read_pdb('./data/3eiy.pdb') reference_point = (9.362, 41.410, 10.542) distances = p_1.distance(xyz=reference_point, records=('ATOM',)) [File link: 3eiy.pdb ] The distance method returns a Pandas Series object: distances.head() 0 19.267419 1 18.306060 2 16.976934 3 16.902897 4 18.124171 dtype: float64 And we can use this Series object, for instance, to select certain atoms in our DataFrame that fall within a desired distance threshold. For example, let's select all atoms that are within 7A of our reference point: all_within_7A = p_1.df['ATOM'][distances < 7.0] all_within_7A.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 786 ATOM 787 CB ... C NaN 1395 787 ATOM 788 CG ... C NaN 1396 788 ATOM 789 CD1 ... C NaN 1397 789 ATOM 790 CD2 ... C NaN 1398 790 ATOM 791 N ... N NaN 1399 5 rows \u00d7 21 columns Visualized in PyMOL, this subset (yellow surface) would look as follows: Converting Amino Acid codes from 3- to 1-letter codes Residues in the residue_name field can be converted into 1-letter amino acid codes, which may be useful for further sequence analysis, for example, pair-wise or multiple sequence alignments: from biopandas.pdb import PandasPdb ppdb = PandasPdb().fetch_pdb('5mtn') sequence = ppdb.amino3to1() sequence.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } chain_id residue_name 1378 B I 1386 B N 1394 B Y 1406 B R 1417 B T As shown above, the amino3to1 method returns a DataFrame containing the chain_id and residue_name of the translated 1-letter amino acids. If you like to work with the sequence as a Python list of string characters, you could do the following: sequence_list = list(sequence.loc[sequence['chain_id'] == 'A', 'residue_name']) sequence_list[-5:] # last 5 residues of chain A ['V', 'R', 'H', 'Y', 'T'] And if you prefer to work with the sequence as a string, you can use the join method: ''.join(sequence.loc[sequence['chain_id'] == 'A', 'residue_name']) 'SLEPEPWFFKNLSRKDAERQLLAPGNTHGSFLIRESESTAGSFSLSVRDFDQGEVVKHYKIRNLDNGGFYISPRITFPGLHELVRHYT' To iterate over the sequences of multi-chain proteins, you can use the unique method as shown below: for chain_id in sequence['chain_id'].unique(): print('\\nChain ID: %s' % chain_id) print(''.join(sequence.loc[sequence['chain_id'] == chain_id, 'residue_name'])) Chain ID: A SLEPEPWFFKNLSRKDAERQLLAPGNTHGSFLIRESESTAGSFSLSVRDFDQGEVVKHYKIRNLDNGGFYISPRITFPGLHELVRHYT Chain ID: B SVSSVPTKLEVVAATPTSLLISWDAPAVTVVYYLITYGETGSPWPGGQAFEVPGSKSTATISGLKPGVDYTITVYAHRSSYGYSENPISINYRT Wrapping it up - Saving PDB structures Finally, let's talk about how to get the PDB structures out of the DataFrame format back into the beloved .pdb format. Let's say we loaded a PDB structure, removed it from it's hydrogens: from biopandas.pdb import PandasPdb ppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz') ppdb.df['ATOM'] = ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H'] [File link: 3eiy.pdb.gz ] We can save the file using the PandasPdb.to_pdb method: ppdb.to_pdb(path='./data/3eiy_stripped.pdb', records=None, gz=False, append_newline=True) [File link: 3eiy_stripped.pdb ] By default, all records (that is, 'ATOM', 'HETATM', 'OTHERS', 'ANISOU') are written if we set records=None . Alternatively, let's say we want to get rid of the 'ANISOU' entries and produce a compressed gzip archive of our PDB structure: ppdb.to_pdb(path='./data/3eiy_stripped.pdb.gz', records=['ATOM', 'HETATM', 'OTHERS'], gz=True, append_newline=True) [File link: 3eiy_stripped.pdb.gz ]","title":"Working with PDB Structures in DataFrames"},{"location":"tutorials/test/#working-with-pdb-structures-in-dataframes","text":"","title":"Working with PDB Structures in DataFrames"},{"location":"tutorials/test/#loading-pdb-files","text":"There are 2 1/2 ways to load a PDB structure into a PandasPdb object.","title":"Loading PDB Files"},{"location":"tutorials/test/#1","text":"PDB files can be directly fetched from The Protein Data Bank at http://www.rcsb.org via its unique 4-letter after initializing a new PandasPdb object and calling the fetch_pdb method: from biopandas.pdb import PandasPdb # Initialize a new PandasPdb object # and fetch the PDB file from rcsb.org ppdb = PandasPdb().fetch_pdb('3eiy')","title":"1"},{"location":"tutorials/test/#2-a","text":"Alternatively, we can load PDB files from local directories as regular PDB files using read_pdb : ppdb.read_pdb('./data/3eiy.pdb') <biopandas.pdb.pandas_pdb.PandasPdb at 0x11912b710> [File link: 3eiy.pdb ]","title":"2 a)"},{"location":"tutorials/test/#2-b","text":"Or, we can load them from gzip archives like so (note that the file must end with a '.gz' suffix in order to be recognized as a gzip file): ppdb.read_pdb('./data/3eiy.pdb.gz') <biopandas.pdb.pandas_pdb.PandasPdb at 0x11912b710> [File link: 3eiy.pdb.gz ] After the file was succesfully loaded, we have access to the following attributes: print('PDB Code: %s' % ppdb.code) print('PDB Header Line: %s' % ppdb.header) print('\\nRaw PDB file contents:\\n\\n%s\\n...' % ppdb.pdb_text[:1000]) PDB Code: 3eiy PDB Header Line: HYDROLASE 17-SEP-08 3EIY Raw PDB file contents: HEADER HYDROLASE 17-SEP-08 3EIY TITLE CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHATASE FROM BURKHOLDERIA TITLE 2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE COMPND MOL_ID: 1; COMPND 2 MOLECULE: INORGANIC PYROPHOSPHATASE; COMPND 3 CHAIN: A; COMPND 4 EC: 3.6.1.1; COMPND 5 ENGINEERED: YES SOURCE MOL_ID: 1; SOURCE 2 ORGANISM_SCIENTIFIC: BURKHOLDERIA PSEUDOMALLEI 1710B; SOURCE 3 ORGANISM_TAXID: 320372; SOURCE 4 GENE: PPA, BURPS1710B_1237; SOURCE 5 EXPRESSION_SYSTEM ... The most interesting / useful attribute is the PandasPdb.df DataFrame dictionary though, which gives us access to the PDB files as pandas DataFrames. Let's print the first 3 lines from the ATOM coordinate section to see how it looks like: ppdb.df['ATOM'].head(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 rows \u00d7 21 columns But more on that in the next section.","title":"2 b)"},{"location":"tutorials/test/#looking-at-pdbs-in-dataframes","text":"PDB files are parsed according to the PDB file format description . More specifically, BioPandas reads the columns of the ATOM and HETATM sections as shown in the following excerpt from http://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM . COLUMNS DATA TYPE CONTENTS biopandas column name 1 - 6 Record name \"ATOM\" record_name 7 - 11 Integer Atom serial number. atom_number 12 blank_1 13 - 16 Atom Atom name. atom_name 17 Character Alternate location indicator. alt_loc 18 - 20 Residue name Residue name. residue_name 21 blank_2 22 Character Chain identifier. chain_id 23 - 26 Integer Residue sequence number. residue_number 27 AChar Code for insertion of residues. insertion 28 - 30 blank_3 31 - 38 Real(8.3) Orthogonal coordinates for X in Angstroms. x_coord 39 - 46 Real(8.3) Orthogonal coordinates for Y in Angstroms. y_coord 47 - 54 Real(8.3) Orthogonal coordinates for Z in Angstroms. z_coord 55 - 60 Real(6.2) Occupancy. occupancy 61 - 66 Real(6.2) Temperature factor (Default = 0.0). bfactor 67-72 blank_4 73 - 76 LString(4) Segment identifier, left-justified. segment_id 77 - 78 LString(2) Element symbol, right-justified. element_symbol 79 - 80 LString(2) Charge on the atom. charge Below is an example of how this would look like in an actual PDB file: Example: 1 2 3 4 5 6 7 8 12345678901234567890123456789012345678901234567890123456789012345678901234567890 ATOM 145 N VAL A 25 32.433 16.336 57.540 1.00 11.92 A1 N ATOM 146 CA VAL A 25 31.132 16.439 58.160 1.00 11.85 A1 C ATOM 147 C VAL A 25 30.447 15.105 58.363 1.00 12.34 A1 C ATOM 148 O VAL A 25 29.520 15.059 59.174 1.00 15.65 A1 O ATOM 149 CB AVAL A 25 30.385 17.437 57.230 0.28 13.88 A1 C ATOM 150 CB BVAL A 25 30.166 17.399 57.373 0.72 15.41 A1 C ATOM 151 CG1AVAL A 25 28.870 17.401 57.336 0.28 12.64 A1 C ATOM 152 CG1BVAL A 25 30.805 18.788 57.449 0.72 15.11 A1 C ATOM 153 CG2AVAL A 25 30.835 18.826 57.661 0.28 13.58 A1 C ATOM 154 CG2BVAL A 25 29.909 16.996 55.922 0.72 13.25 A1 C After loading a PDB file from rcsb.org or our local drive, the PandasPdb.df attribute should contain the following 4 DataFrame objects: from biopandas.pdb import PandasPdb ppdb = PandasPdb() ppdb.read_pdb('./data/3eiy.pdb') ppdb.df.keys() dict_keys(['ATOM', 'HETATM', 'ANISOU', 'OTHERS']) [File link: 3eiy.pdb ] 'ATOM': contains the entries from the ATOM coordinate section 'ATOM': ... entries from the \"HETATM\" coordinate section 'ANISOU': ... entries from the \"ANISOU\" coordinate section 'OTHERS': Everything else that is not a 'ATOM', 'HETATM', or 'ANISOU' entry The columns of the 'HETATM' DataFrame are indentical to the 'ATOM' DataFrame that we've seen earlier: ppdb.df['HETATM'].head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 HETATM 1332 K ... K NaN 1940 1 HETATM 1333 NA ... NA NaN 1941 2 rows \u00d7 21 columns Note that \"ANISOU\" entries are handled a bit differently as specified at http://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM . ppdb.df['ANISOU'].head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... blank_4 element_symbol charge line_idx 0 rows \u00d7 21 columns Not every PDB file contains ANISOU entries (similarly, some PDB files may only contain HETATM or ATOM entries). If records are basent, the DataFrame will be empty as show above. ppdb.df['ANISOU'].empty True Since the DataFrames are fairly wide, let's us take a look at the columns by accessing the DataFrame's column attribute: ppdb.df['ANISOU'].columns Index(['record_name', 'atom_number', 'blank_1', 'atom_name', 'alt_loc', 'residue_name', 'blank_2', 'chain_id', 'residue_number', 'insertion', 'blank_3', 'U(1,1)', 'U(2,2)', 'U(3,3)', 'U(1,2)', 'U(1,3)', 'U(2,3)', 'blank_4', 'element_symbol', 'charge', 'line_idx'], dtype='object') ANISOU records are very similar to ATOM/HETATM records. In fact, the columns 7 - 27 and 73 - 80 are identical to their corresponding ATOM/HETATM records, which means that the 'ANISOU' DataFrame doesn't have the following entries: set(ppdb.df['ATOM'].columns).difference(set(ppdb.df['ANISOU'].columns)) {'b_factor', 'occupancy', 'segment_id', 'x_coord', 'y_coord', 'z_coord'} Instead, the \"ANISOU\" DataFrame contains the anisotropic temperature factors \"U(-,-)\" -- note that these are scaled by a factor of 10^4 ( \\text{Angstroms}^2 ) by convention. set(ppdb.df['ANISOU'].columns).difference(set(ppdb.df['ATOM'].columns)) {'U(1,1)', 'U(1,2)', 'U(1,3)', 'U(2,2)', 'U(2,3)', 'U(3,3)'} Ah, another interesting thing to mention is that the columns already come with the types you'd expect (where object essentially \"means\" str here): ppdb.df['ATOM'].dtypes record_name object atom_number int64 blank_1 object atom_name object alt_loc object residue_name object blank_2 object chain_id object residue_number int64 insertion object blank_3 object x_coord float64 y_coord float64 z_coord float64 occupancy float64 b_factor float64 blank_4 object segment_id object element_symbol object charge float64 line_idx int64 dtype: object Typically, all good things come in threes, however, there is a 4th DataFrame, an'OTHER' DataFrame, which contains everything that wasn't parsed as 'ATOM', 'HETATM', or 'ANISOU' coordinate section: ppdb.df['OTHERS'].head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name entry line_idx 0 HEADER HYDROLASE 17... 0 1 TITLE CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHA... 1 2 TITLE 2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE 2 3 COMPND MOL_ID: 1; 3 4 COMPND 2 MOLECULE: INORGANIC PYROPHOSPHATASE; 4 Although these 'OTHER' entries are typically less useful for structure-related computations, you may still want to take a look at them to get a short summary of the PDB structure and learn about it's potential quirks and gotchas (typically listed in the REMARKs section). Lastly, the \"OTHERS\" DataFrame comes in handy if we want to reconstruct the structure as PDB file as we will see later (note the line_idx columns in all of the DataFrames).","title":"Looking at PDBs in DataFrames"},{"location":"tutorials/test/#working-with-pdb-dataframes","text":"In the previous sections, we've seen how to load PDB structures into DataFrames, and how to access them. Now, let's talk about manipulating PDB files in DataFrames. from biopandas.pdb import PandasPdb ppdb = PandasPdb() ppdb.read_pdb('./data/3eiy.pdb.gz') ppdb.df['ATOM'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 ATOM 4 O ... O NaN 612 4 ATOM 5 CB ... C NaN 613 5 rows \u00d7 21 columns [File link: 3eiy.pdb.gz ] Okay, there's actually not that much to say ... Once we have our PDB file in the DataFrame format, we have the whole convenience of pandas right there at our fingertips. For example, let's get all Proline residues: ppdb.df['ATOM'][ppdb.df['ATOM']['residue_name'] == 'PRO'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 38 ATOM 39 N ... N NaN 647 39 ATOM 40 CA ... C NaN 648 40 ATOM 41 C ... C NaN 649 41 ATOM 42 O ... O NaN 650 42 ATOM 43 CB ... C NaN 651 5 rows \u00d7 21 columns Or main chain atoms: ppdb.df['ATOM'][ppdb.df['ATOM']['atom_name'] == 'C'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 2 ATOM 3 C ... C NaN 611 8 ATOM 9 C ... C NaN 617 19 ATOM 20 C ... C NaN 628 25 ATOM 26 C ... C NaN 634 33 ATOM 34 C ... C NaN 642 5 rows \u00d7 21 columns It's also easy to strip our coordinate section from hydrogen atoms if there are any ... ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H'].head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 0 ATOM 1 N ... N NaN 609 1 ATOM 2 CA ... C NaN 610 2 ATOM 3 C ... C NaN 611 3 ATOM 4 O ... O NaN 612 4 ATOM 5 CB ... C NaN 613 5 rows \u00d7 21 columns Or, let's compute the average temperature factor of our protein main chain: mainchain = ppdb.df['ATOM'][(ppdb.df['ATOM']['atom_name'] == 'C') | (ppdb.df['ATOM']['atom_name'] == 'O') | (ppdb.df['ATOM']['atom_name'] == 'N') | (ppdb.df['ATOM']['atom_name'] == 'CA')] bfact_mc_avg = mainchain['b_factor'].mean() print('Average B-Factor [Main Chain]: %.2f' % bfact_mc_avg) Average B-Factor [Main Chain]: 28.83","title":"Working with PDB DataFrames"},{"location":"tutorials/test/#plotting","text":"Since we are using pandas under the hood, which in turns uses matplotlib under the hood, we can produce quick summary plots of our PDB structures relatively conveniently: from biopandas.pdb import PandasPdb ppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz') [File link: 3eiy.pdb.gz ] %matplotlib inline import matplotlib.pyplot as plt from matplotlib import style style.use('ggplot') ppdb.df['ATOM']['b_factor'].plot(kind='hist') plt.title('Distribution of B-Factors') plt.xlabel('B-factor') plt.ylabel('count') plt.show() ppdb.df['ATOM']['b_factor'].plot(kind='line') plt.title('B-Factors Along the Amino Acid Chain') plt.xlabel('Residue Number') plt.ylabel('B-factor in $A^2$') plt.show() ppdb.df['ATOM']['element_symbol'].value_counts().plot(kind='bar') plt.title('Distribution of Atom Types') plt.xlabel('elements') plt.ylabel('count') plt.show()","title":"Plotting"},{"location":"tutorials/test/#computing-the-root-mean-square-deviation","text":"BioPandas also comes with certain convenience functions, for example, ... The Root-mean-square deviation (RMSD) is simply a measure of the average distance between atoms of 2 protein or ligand structures. This calculation of the Cartesian error follows the equation: RMSD(a, b) = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} \\big((a_{ix})^2 + (a_{iy})^2 + (a_{iz})^2 \\big)} \\\\ = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} || a_i + b_i||_2^2} So, assuming that the we have the following 2 conformations of a ligand molecule we can compute the RMSD as follows: from biopandas.pdb import PandasPdb l_1 = PandasPdb().read_pdb('./data/lig_conf_1.pdb') l_2 = PandasPdb().read_pdb('./data/lig_conf_2.pdb') r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s=None) # all atoms, including hydrogens print('RMSD: %.4f Angstrom' % r) RMSD: 2.6444 Angstrom [File links: lig_conf_1.pdb , lig_conf_2.pdb ] r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s='carbon') # carbon atoms only print('RMSD: %.4f Angstrom' % r) RMSD: 3.1405 Angstrom r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], s='heavy') # heavy atoms only print('RMSD: %.4f Angstrom' % r) RMSD: 1.9959 Angstrom Similarly, we can compute the RMSD between 2 related protein structures: The hydrogen-free RMSD: p_1 = PandasPdb().read_pdb('./data/1t48_995.pdb') p_2 = PandasPdb().read_pdb('./data/1t49_995.pdb') r = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='heavy') print('RMSD: %.4f Angstrom' % r) RMSD: 0.7377 Angstrom Or the RMSD between the main chains only: p_1 = PandasPdb().read_pdb('./data/1t48_995.pdb') p_2 = PandasPdb().read_pdb('./data/1t49_995.pdb') r = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='main chain') print('RMSD: %.4f Angstrom' % r) RMSD: 0.4781 Angstrom","title":"Computing the Root Mean Square Deviation"},{"location":"tutorials/test/#filtering-pdbs-by-distance","text":"We can use the distance method to compute the distance between each atom (or a subset of atoms) in our data frame and a three-dimensional reference point. For example: p_1 = PandasPdb().read_pdb('./data/3eiy.pdb') reference_point = (9.362, 41.410, 10.542) distances = p_1.distance(xyz=reference_point, records=('ATOM',)) [File link: 3eiy.pdb ] The distance method returns a Pandas Series object: distances.head() 0 19.267419 1 18.306060 2 16.976934 3 16.902897 4 18.124171 dtype: float64 And we can use this Series object, for instance, to select certain atoms in our DataFrame that fall within a desired distance threshold. For example, let's select all atoms that are within 7A of our reference point: all_within_7A = p_1.df['ATOM'][distances < 7.0] all_within_7A.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } record_name atom_number blank_1 atom_name ... segment_id element_symbol charge line_idx 786 ATOM 787 CB ... C NaN 1395 787 ATOM 788 CG ... C NaN 1396 788 ATOM 789 CD1 ... C NaN 1397 789 ATOM 790 CD2 ... C NaN 1398 790 ATOM 791 N ... N NaN 1399 5 rows \u00d7 21 columns Visualized in PyMOL, this subset (yellow surface) would look as follows:","title":"Filtering PDBs by Distance"},{"location":"tutorials/test/#converting-amino-acid-codes-from-3-to-1-letter-codes","text":"Residues in the residue_name field can be converted into 1-letter amino acid codes, which may be useful for further sequence analysis, for example, pair-wise or multiple sequence alignments: from biopandas.pdb import PandasPdb ppdb = PandasPdb().fetch_pdb('5mtn') sequence = ppdb.amino3to1() sequence.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } chain_id residue_name 1378 B I 1386 B N 1394 B Y 1406 B R 1417 B T As shown above, the amino3to1 method returns a DataFrame containing the chain_id and residue_name of the translated 1-letter amino acids. If you like to work with the sequence as a Python list of string characters, you could do the following: sequence_list = list(sequence.loc[sequence['chain_id'] == 'A', 'residue_name']) sequence_list[-5:] # last 5 residues of chain A ['V', 'R', 'H', 'Y', 'T'] And if you prefer to work with the sequence as a string, you can use the join method: ''.join(sequence.loc[sequence['chain_id'] == 'A', 'residue_name']) 'SLEPEPWFFKNLSRKDAERQLLAPGNTHGSFLIRESESTAGSFSLSVRDFDQGEVVKHYKIRNLDNGGFYISPRITFPGLHELVRHYT' To iterate over the sequences of multi-chain proteins, you can use the unique method as shown below: for chain_id in sequence['chain_id'].unique(): print('\\nChain ID: %s' % chain_id) print(''.join(sequence.loc[sequence['chain_id'] == chain_id, 'residue_name'])) Chain ID: A SLEPEPWFFKNLSRKDAERQLLAPGNTHGSFLIRESESTAGSFSLSVRDFDQGEVVKHYKIRNLDNGGFYISPRITFPGLHELVRHYT Chain ID: B SVSSVPTKLEVVAATPTSLLISWDAPAVTVVYYLITYGETGSPWPGGQAFEVPGSKSTATISGLKPGVDYTITVYAHRSSYGYSENPISINYRT","title":"Converting Amino Acid codes from 3- to 1-letter codes"},{"location":"tutorials/test/#wrapping-it-up-saving-pdb-structures","text":"Finally, let's talk about how to get the PDB structures out of the DataFrame format back into the beloved .pdb format. Let's say we loaded a PDB structure, removed it from it's hydrogens: from biopandas.pdb import PandasPdb ppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz') ppdb.df['ATOM'] = ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H'] [File link: 3eiy.pdb.gz ] We can save the file using the PandasPdb.to_pdb method: ppdb.to_pdb(path='./data/3eiy_stripped.pdb', records=None, gz=False, append_newline=True) [File link: 3eiy_stripped.pdb ] By default, all records (that is, 'ATOM', 'HETATM', 'OTHERS', 'ANISOU') are written if we set records=None . Alternatively, let's say we want to get rid of the 'ANISOU' entries and produce a compressed gzip archive of our PDB structure: ppdb.to_pdb(path='./data/3eiy_stripped.pdb.gz', records=['ATOM', 'HETATM', 'OTHERS'], gz=True, append_newline=True) [File link: 3eiy_stripped.pdb.gz ]","title":"Wrapping it up - Saving PDB structures"}]}